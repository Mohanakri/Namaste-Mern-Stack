# JavaScript Glossary - Enhanced Reference Guide

---

## **VARIABLES & DATA TYPES**

| Term | Definition | When to Use | Example | Remarks |
|------|------------|-------------|---------|---------|
| **var** | Function-scoped variable declaration (legacy, can be redeclared) | Avoid in modern code; only for legacy browser support | ```javascript<br>var age = 25;<br>var age = 30; // allowed<br>function test() {<br>  console.log(age); // 30<br>}<br>``` | **Limitations**: Function-scoped (not block-scoped), hoisted, can cause bugs. ES6 introduced `let` and `const` to solve these issues. |
| **let** | Block-scoped variable declaration (ES6+, cannot be redeclared) | When variable value will change | ```javascript<br>let count = 0;<br>count = 1; // allowed<br>// let count = 2; // Error!<br>if (true) {<br>  let blockVar = 'local';<br>}<br>// console.log(blockVar); // Error!<br>``` | **Improvement over var**: Block-scoped, prevents accidental redeclaration, has Temporal Dead Zone (TDZ) for safer code. |
| **const** | Block-scoped constant (cannot be reassigned) | Default choice for all variables; when value won't change | ```javascript<br>const API_KEY = 'abc123';<br>// API_KEY = 'xyz'; // Error!<br>const user = { name: 'Alice' };<br>user.name = 'Bob'; // OK (mutating object)<br>// user = {}; // Error (reassigning)<br>``` | **Note**: Prevents reassignment, NOT immutability. Objects/arrays can still be mutated. Use `Object.freeze()` for true immutability. |
| **String** | Textual data enclosed in quotes | For text, messages, names, IDs | ```javascript<br>const greeting = "Hello World";<br>const name = 'Alice';<br>const message = `Hi ${name}!`;<br>const multiline = `Line 1<br>Line 2`;<br>``` | **Template literals** (backticks) enable string interpolation and multi-line strings, solving concatenation messiness. |
| **Number** | Numeric data (integers, decimals, scientific notation) | For calculations, counters, measurements | ```javascript<br>const age = 30;<br>const price = 19.99;<br>const scientific = 5e3; // 5000<br>const hex = 0xFF; // 255<br>const binary = 0b1010; // 10<br>``` | **Limitation**: Only one number type (unlike other languages). Max safe integer: 2^53 - 1. Use `BigInt` for larger numbers. |
| **Boolean** | Logical true/false values | For conditions, flags, toggles | ```javascript<br>const isActive = true;<br>const hasAccess = false;<br>const isValid = 5 > 3; // true<br>const isEmpty = !user.name;<br>``` | **Truthy/Falsy**: JS coerces values in conditions. Falsy: `false`, `0`, `''`, `null`, `undefined`, `NaN`. Everything else is truthy. |
| **Undefined** | Variable declared but not assigned a value | Default state; checking if property exists | ```javascript<br>let user;<br>console.log(user); // undefined<br>console.log(obj.missing); // undefined<br>function noReturn() {}<br>console.log(noReturn()); // undefined<br>``` | **Automatic**: JS assigns `undefined` automatically. Not explicitly set by programmer (unlike `null`). |
| **Null** | Intentional absence of value (programmer-assigned) | Explicitly clearing values; API responses | ```javascript<br>let selectedItem = null;<br>const response = data ?? null;<br>if (user === null) {<br>  console.log('No user');<br>}<br>``` | **Note**: `typeof null` returns `"object"` (historical JS bug). Use `=== null` for checking. Represents "no value" intentionally. |
| **Symbol** | Unique, immutable identifier (useful for object keys) | Creating unique property keys; avoiding collisions | ```javascript<br>const id = Symbol('userId');<br>const id2 = Symbol('userId');<br>console.log(id === id2); // false<br>const obj = {<br>  [id]: 12345,<br>  name: 'Alice'<br>};<br>``` | **Use case**: Guaranteed uniqueness. Useful for meta-properties, avoiding key conflicts in objects. Not enumerable in loops. |
| **BigInt** | Arbitrarily large integers beyond Number.MAX_SAFE_INTEGER | Large numbers, cryptography, precise calculations | ```javascript<br>const huge = 9007199254740991n;<br>const big = BigInt("12345678901234567890");<br>const calc = huge + 100n;<br>// const mixed = huge + 100; // Error!<br>``` | **Limitation**: Cannot mix with regular Numbers. Must use `n` suffix or `BigInt()` constructor. Added in ES2020. |

---

## **FUNCTIONS**

| Term | Definition | When to Use | Example | Remarks |
|------|------------|-------------|---------|---------|
| **Function Declaration** | Named function hoisted to top of scope | When you need hoisting; top-level utility functions | ```javascript<br>calculateTotal(100, 0.08); // Works!<br><br>function calculateTotal(price, tax) {<br>  return price + (price * tax);<br>}<br>``` | **Hoisting advantage**: Can be called before declaration. Good for code organization. Creates named function (better for debugging). |
| **Function Expression** | Function assigned to variable (not hoisted) | When function is conditional; creating closures | ```javascript<br>// multiply(); // Error! Not hoisted<br><br>const multiply = function(a, b) {<br>  return a * b;<br>};<br><br>const divide = condition<br>  ? function(a, b) { return a / b; }<br>  : function(a, b) { return 0; };<br>``` | **Not hoisted**: Must be declared before use. Useful for conditional function creation. Often used with higher-order functions. |
| **Arrow Function** | Concise syntax, lexical this binding | Callbacks, array methods, when you don't need 'this' binding | ```javascript<br>const square = x => x * x;<br>const add = (a, b) => a + b;<br>const greet = name => `Hello ${name}`;<br><br>// Multi-line needs braces<br>const complex = (x, y) => {<br>  const result = x * y;<br>  return result + 10;<br>};<br>``` | **Key difference**: No own `this`, `arguments`, `super`. Inherits `this` from parent scope. Cannot be used as constructors. Solved `this` binding issues in callbacks. |
| **IIFE** | Immediately Invoked Function Expression | Creating private scope; initialization code | ```javascript<br>(function() {<br>  const privateVar = "secret";<br>  console.log("I run immediately!");<br>})();<br><br>// Arrow IIFE<br>(() => {<br>  const data = fetchData();<br>  processData(data);<br>})();<br>``` | **Pre-ES6 solution**: Created private scope before `let`/`const`. Still useful for initialization code, avoiding global pollution. |
| **Callback** | Function passed as argument to be executed later | Event handlers, async operations, array methods | ```javascript<br>[1, 2, 3].forEach(num => {<br>  console.log(num * 2);<br>});<br><br>setTimeout(() => {<br>  console.log("Done");<br>}, 1000);<br><br>button.addEventListener('click', () => {<br>  handleClick();<br>});<br>``` | **Limitation**: Leads to "callback hell" with nested async operations. Promises and async/await were created to solve this readability issue. |
| **Higher-Order Function** | Function that accepts/returns functions | Creating utilities, decorators, function composition | ```javascript<br>function withLogging(fn) {<br>  return function(...args) {<br>    console.log('Calling:', fn.name);<br>    const result = fn(...args);<br>    console.log('Result:', result);<br>    return result;<br>  };<br>}<br><br>const add = (a, b) => a + b;<br>const loggedAdd = withLogging(add);<br>``` | **Powerful pattern**: Enables functional programming. Used in libraries like Lodash, Redux. Array methods (`map`, `filter`) are HOFs. |
| **Closure** | Function retains access to outer scope after outer function returns | Data privacy, creating factories, memoization | ```javascript<br>function counter() {<br>  let count = 0;<br>  return {<br>    increment: () => ++count,<br>    decrement: () => --count,<br>    getValue: () => count<br>  };<br>}<br><br>const myCounter = counter();<br>myCounter.increment(); // 1<br>myCounter.increment(); // 2<br>``` | **Key concept**: Creates private variables. Each function instance has its own closure. Foundation for many JS patterns (modules, factories). |
| **Rest Parameters** | Collects indefinite arguments into array | Unknown number of arguments; replacing 'arguments' object | ```javascript<br>function sum(...numbers) {<br>  return numbers.reduce((a, b) => a + b, 0);<br>}<br><br>sum(1, 2, 3, 4); // 10<br><br>function log(level, ...messages) {<br>  console.log(`[${level}]`, ...messages);<br>}<br>``` | **Improvement**: Cleaner than `arguments` object. Creates real array. Must be last parameter. Works with arrow functions (unlike `arguments`). |
| **Default Parameters** | Provides fallback values for missing arguments | Optional parameters; avoiding undefined checks | ```javascript<br>function greet(name = "Guest", time = "day") {<br>  return `Good ${time}, ${name}!`;<br>}<br><br>greet(); // "Good day, Guest!"<br>greet("Alice"); // "Good day, Alice!"<br>greet("Bob", "evening"); // "Good evening, Bob!"<br>``` | **ES6 feature**: Cleaner than `name = name || "Guest"`. Evaluated at call time. Can use previous parameters in defaults. |

---

## **OBJECTS & ARRAYS**

| Term | Definition | When to Use | Example | Remarks |
|------|------------|-------------|---------|---------|
| **Object** | Collection of key-value pairs representing entities | Storing related data; modeling real-world entities | ```javascript<br>const user = {<br>  name: "Alice",<br>  age: 30,<br>  email: "alice@example.com",<br>  greet() {<br>    return `Hi, I'm ${this.name}`;<br>  }<br>};<br>``` | **Foundation**: Everything in JS (except primitives) is an object. Passed by reference. Use for structured, related data. |
| **Array** | Ordered list of values accessed by numeric index | Lists, collections, ordered data | ```javascript<br>const colors = ["red", "green", "blue"];<br>colors[0]; // "red"<br>colors.length; // 3<br>colors.push("yellow");<br>colors.pop(); // "yellow"<br>``` | **Special object**: Actually an object with numeric keys. Has built-in methods. Use for ordered collections. Zero-indexed. |
| **Object Literal** | Direct object creation using {} notation | Quick object creation; configuration objects | ```javascript<br>const book = {<br>  title: "1984",<br>  author: "Orwell",<br>  year: 1949,<br>  getSummary() {<br>    return `${this.title} by ${this.author}`;<br>  }<br>};<br>``` | **Most common**: Simple, readable syntax. ES6 added method shorthand. Use for single-use objects and configurations. |
| **Array Destructuring** | Extract array values into separate variables | Unpacking values; swapping variables; function returns | ```javascript<br>const [first, second, ...rest] = [1, 2, 3, 4, 5];<br>// first=1, second=2, rest=[3,4,5]<br><br>// Skipping elements<br>const [a, , c] = [1, 2, 3];<br><br>// Swapping<br>[x, y] = [y, x];<br><br>// With defaults<br>const [val = 10] = [];<br>``` | **ES6 feature**: Cleaner than index access. Works with any iterable. Enables elegant swaps. Common in React hooks: `[state, setState]`. |
| **Object Destructuring** | Extract object properties into variables | Function parameters; extracting API data; imports | ```javascript<br>const user = { name: 'Alice', age: 30, city: 'NYC' };<br>const { name, age, city = 'Unknown' } = user;<br><br>// Renaming<br>const { name: userName } = user;<br><br>// Nested<br>const { address: { street } } = person;<br><br>// Function params<br>function greet({ name, age }) {<br>  return `${name} is ${age}`;<br>}<br>``` | **Powerful**: Reduces boilerplate. Works with nested objects. Combine with default values. Commonly used in React props, API responses. |
| **Spread Operator** | Expands iterables or copies objects/arrays | Copying, merging, passing array as arguments | ```javascript<br>const arr = [1, 2, 3];<br>const copy = [...arr];<br>const merged = [...arr1, ...arr2];<br><br>const obj = { name: 'Alice' };<br>const updated = {<br>  ...obj,<br>  age: 30,<br>  name: 'Bob' // overwrites<br>};<br><br>Math.max(...numbers);<br>``` | **Note**: Creates shallow copy. Nested objects are still referenced. For deep copy, use `structuredClone()` or libraries. |
| **Property Shorthand** | Concise syntax when key matches variable name | Reducing boilerplate; cleaner object literals | ```javascript<br>const name = "Bob";<br>const age = 25;<br><br>// Old way<br>const person1 = { name: name, age: age };<br><br>// ES6 shorthand<br>const person2 = { name, age };<br>``` | **ES6 convenience**: Reduces repetition. Very common in modern JS. Works with destructuring too. |
| **Computed Property** | Dynamic property names using [] | Dynamic keys; creating objects programmatically | ```javascript<br>const propName = "score";<br>const game = {<br>  [propName]: 100,<br>  [`level_${2}`]: "hard",<br>  [Symbol('id')]: 123<br>};<br><br>// Dynamic object creation<br>const key = getUserInput();<br>const obj = { [key]: value };<br>``` | **ES6 feature**: Enables dynamic property names at creation time. Before ES6, had to create object first, then add property. |

---

## **ASYNCHRONOUS PROGRAMMING**

| Term | Definition | When to Use | Example | Remarks |
|------|------------|-------------|---------|---------|
| **Promise** | Object representing eventual success/failure of async operation | HTTP requests, file operations, any async task | ```javascript<br>const fetchData = new Promise((resolve, reject) => {<br>  setTimeout(() => {<br>    const success = true;<br>    if (success) {<br>      resolve("Data loaded!");<br>    } else {<br>      reject("Error loading data");<br>    }<br>  }, 1000);<br>});<br><br>fetchData<br>  .then(data => console.log(data))<br>  .catch(err => console.error(err));<br>``` | **Solution to callback hell**: Chainable, better error handling. Three states: pending, fulfilled, rejected. Foundation for async/await. |
| **async/await** | Syntactic sugar making promises look synchronous | Making async code readable; when using promises | ```javascript<br>async function getUser() {<br>  try {<br>    const response = await fetch('/api/user');<br>    const data = await response.json();<br>    return data;<br>  } catch (error) {<br>    console.error('Failed:', error);<br>    throw error;<br>  }<br>}<br><br>// Using it<br>const user = await getUser();<br>``` | **Modern standard**: Cleaner than `.then()` chains. Must use `try/catch` for errors. `await` only works in async functions or top-level modules. |
| **setTimeout** | Executes code once after specified delay (ms) | Delays, debouncing, temporary UI states | ```javascript<br>setTimeout(() => {<br>  console.log("Runs after 2 seconds");<br>}, 2000);<br><br>// Canceling<br>const timerId = setTimeout(() => {}, 1000);<br>clearTimeout(timerId);<br><br>// With arguments<br>setTimeout(greet, 1000, "Alice", "Hello");<br>``` | **Not precise**: Minimum delay, not guaranteed. Part of Web API, not JS core. `0ms` delay still queues for next event loop tick. |
| **setInterval** | Executes code repeatedly at fixed intervals | Polling, animations, timers, auto-refresh | ```javascript<br>const timer = setInterval(() => {<br>  console.log("Every second");<br>  count++;<br>  if (count > 10) {<br>    clearInterval(timer);<br>  }<br>}, 1000);<br><br>// Better: recursive setTimeout<br>function repeat() {<br>  doWork();<br>  setTimeout(repeat, 1000);<br>}<br>``` | **Drift issue**: Can accumulate delay. Doesn't wait for completion. Consider recursive `setTimeout` or `requestAnimationFrame` for animations. |
| **Callback Hell** | Deeply nested callbacks causing readability issues | Anti-pattern to avoid; refactor to promises/async-await | ```javascript<br>// Bad: Pyramid of doom<br>getData(function(a) {<br>  getMoreData(a, function(b) {<br>    getEvenMore(b, function(c) {<br>      getFinal(c, function(d) {<br>        console.log(d);<br>      });<br>    });<br>  });<br>});<br><br>// Good: Async/await<br>const a = await getData();<br>const b = await getMoreData(a);<br>const c = await getEvenMore(b);<br>const d = await getFinal(c);<br>``` | **Historical problem**: Promises introduced to solve this. Async/await makes it even cleaner. Named functions and modularization also help. |
| **Promise.all** | Waits for all promises to resolve (fails if any reject) | Parallel requests, loading multiple resources | ```javascript<br>const [users, posts, comments] = await Promise.all([<br>  fetch('/api/users'),<br>  fetch('/api/posts'),<br>  fetch('/api/comments')<br>].map(p => p.then(r => r.json())));<br><br>// If one fails, all fail<br>Promise.all([promise1, promise2])<br>  .then(results => console.log(results))<br>  .catch(err => console.log('One failed:', err));<br>``` | **Fast parallel execution**: Runs concurrently. Fails fast (one reject = all reject). Use `Promise.allSettled()` if you want all results regardless of failures. |
| **Promise.race** | Resolves/rejects with first promise to settle | Timeouts, racing servers, cancellation | ```javascript<br>// Timeout pattern<br>const result = await Promise.race([<br>  fetch('/api/data'),<br>  new Promise((_, reject) =><br>    setTimeout(() => reject('Timeout'), 5000)<br>  )<br>]);<br><br>// Fastest response wins<br>const fastest = await Promise.race([<br>  fetch('/server1'),<br>  fetch('/server2')<br>]);<br>``` | **First wins**: Returns as soon as one promise settles. Useful for implementing timeouts. `Promise.any()` waits for first fulfillment (ignores rejections). |
| **Event Loop** | JS runtime mechanism handling async code execution | Understanding async behavior; debugging timing issues | ```javascript<br>console.log('1'); // Sync<br><br>setTimeout(() => console.log('2'), 0); // Macro task<br><br>Promise.resolve()<br>  .then(() => console.log('3')); // Micro task<br><br>console.log('4'); // Sync<br><br>// Output: 1, 4, 3, 2<br>``` | **Critical concept**: Call stack → Microtasks (promises) → Macrotasks (setTimeout). Understanding this explains async behavior. Promises execute before setTimeout. |

---

## **OOP & CLASSES**

| Term | Definition | When to Use | Example | Remarks |
|------|------------|-------------|---------|---------|
| **Class** | Blueprint for creating objects with shared properties/methods | Creating multiple similar objects; modeling entities | ```javascript<br>class Car {<br>  constructor(brand, model) {<br>    this.brand = brand;<br>    this.model = model;<br>  }<br><br>  drive() {<br>    return `${this.brand} ${this.model} is driving`;<br>  }<br><br>  static compare(car1, car2) {<br>    return car1.brand === car2.brand;<br>  }<br>}<br>``` | **ES6 syntactic sugar**: Under the hood, still prototypal inheritance. Cleaner than function constructors. Not hoisted (unlike function declarations). |
| **Constructor** | Special method called when creating new instance | Initializing instance properties; setup logic | ```javascript<br>class User {<br>  constructor(name, email) {<br>    this.name = name;<br>    this.email = email;<br>    this.createdAt = new Date();<br>  }<br>}<br><br>const user = new User("Alice", "a@b.com");<br>console.log(user.name); // "Alice"<br>``` | **Initialization**: Runs automatically with `new`. Only one constructor per class. Must call `super()` first if extending another class. |
| **this** | Refers to current object instance context | Accessing instance properties/methods | ```javascript<br>const obj = {<br>  name: "Test",<br>  greet() {<br>    return `Hello, I'm ${this.name}`;<br>  },<br>  arrowGreet: () => {<br>    return `Hi ${this.name}`; // undefined!<br>  }<br>};<br><br>obj.greet(); // Works<br>const fn = obj.greet;<br>fn(); // this = undefined (strict mode)<br>``` | **Context-dependent**: Value determined by how function is called. Arrow functions inherit `this` from parent scope. Common source of bugs. Use `.bind()`, arrow functions, or class properties to fix. |
| **Inheritance** | Class derives properties/methods from parent class | Code reuse; creating hierarchies; specialization | ```javascript<br>class Animal {<br>  constructor(name) {<br>    this.name = name;<br>  }<br>  eat() {<br>    return `${this.name} is eating`;<br>  }<br>}<br><br>class Dog extends Animal {<br>  bark() {<br>    return "Woof!";<br>  }<br>}<br><br>const dog = new Dog("Buddy");<br>dog.eat(); // From Animal<br>dog.bark(); // From Dog<br>``` | **Prototype chain**: Child inherits from parent. Use composition over inheritance when possible. Deep inheritance hierarchies can be hard to maintain. |
| **super** | Calls parent class constructor or methods | Extending parent behavior; accessing parent methods | ```javascript<br>class Employee extends Person {<br>  constructor(name, role) {<br>    super(name); // Must call first<br>    this.role = role;<br>  }<br><br>  introduce() {<br>    return `${super.introduce()}, Role: ${this.role}`;<br>  }<br>}<br>``` | **Required in constructor**: Must call `super()` before using `this`. Can also call parent methods with `super.methodName()`. |
| **Prototype** | Object template from which other objects inherit | Understanding inheritance; adding methods to built-ins | ```javascript<br>// Every object has a prototype<br>const arr = [1, 2, 3];<br>console.log(arr.__proto__ === Array.prototype);<br><br>// Adding method to all arrays<br>Array.prototype.last = function() {<br>  return this[this.length - 1];<br>};<br><br>[1, 2, 3].last(); // 3<br>``` | **Foundation of JS**: Everything inherits from prototype chain. Modifying built-in prototypes is generally discouraged. Classes are syntactic sugar over prototypes. |
| **Static Method** | Method belonging to class itself, not instances | Utility functions; factory methods; constants | ```javascript<br>class MathUtil {<br>  static add(a, b) {<br>    return a + b;<br>  }<br><br>  static PI = 3.14159;<br><br>  static createFromString(str) {<br>    return new MathUtil(parseFloat(str));<br>  }<br>}<br><br>MathUtil.add(5, 3); // 8<br>// const util = new MathUtil();<br>// util.add(5, 3); // Error!<br>``` | **Class-level**: Called on class, not instance. No access to `this` (instance). Good for factory methods, utilities, constants. |
| **Getter/Setter** | Computed properties with get/set access control | Computed values; validation; encapsulation | ```javascript<br>class Circle {<br>  constructor(radius) {<br>    this._radius = radius;<br>  }<br><br>  get diameter() {<br>    return this._radius * 2;<br>  }<br><br>  set diameter(d) {<br>    if (d < 0) throw new Error("Invalid");<br>    this._radius = d / 2;<br>  }<br><br>  get area() {<br>    return Math.PI * this._radius ** 2;<br>  }<br>}<br>``` | **Computed properties**: Looks like property, acts like method. Use for validation, computed values, lazy loading. Convention: prefix private properties with `_`. |

---

## **OPERATORS**

| Term | Definition | When to Use | Example | Remarks |
|------|------------|-------------|---------|---------|
| **Strict Equality (===)** | Compares value AND type (no coercion) | Always prefer over ==; comparing values safely | ```javascript<br>5 === 5; // true<br>5 === "5"; // false<br>null === undefined; // false<br>0 === false; // false<br>NaN === NaN; // false (quirk!)<br>``` | **Best practice**: Always use `===` and `!==`. Avoids type coercion bugs. For `NaN`, use `Number.isNaN()`. For object comparison, use `Object.is()`. |
| **Loose Equality (==)** | Compares values with type coercion | Avoid; only when you explicitly want coercion | ```javascript<br>5 == "5"; // true (coercion)<br>null == undefined; // true<br>0 == false; // true<br>"" == false; // true<br>[] == false; // true<br>``` | **Unpredictable**: Complex coercion rules cause bugs. Rarely needed. If you need coercion, be explicit with conversion. |
| **Ternary Operator** | Inline conditional expression (if-else shorthand) | Simple conditionals; inline assignments | ```javascript<br>const status = age >= 18 ? "adult" : "minor";<br><br>const color = isActive<br>  ? "green"<br>  : "red";<br><br>// Nested (avoid if complex)<br>const size = width > 1200<br>  ? "large"<br>  : width > 800<br>    ? "medium"<br>    : "small";<br>``` | **Concise**: Good for simple conditions. Avoid deep nesting (hard to read). Can't use statements (only expressions). |
| **Nullish Coalescing (??)** | Returns right side only if left is null/undefined | Default values; avoiding falsy value issues with \|\| | ```javascript<br>const name = userName ?? "Anonymous";<br>const count = 0 ?? 10; // 0 (not nullish)<br>const value = "" ?? "default"; // "" (not nullish)<br>const result = null ?? "fallback"; // "fallback"<br>``` | **ES2020**: Better than `||` for defaults. Only treats `null`/`undefined` as nullish. Preserves `0`, `""`, `false`. |
| **Optional Chaining (?.)** | Safely access nested properties without errors | Accessing deep properties; avoiding null checks | ```javascript<br>const city = user?.address?.city;<br>const result = obj?.method?.();<br>const item = arr?.[0];<br><br>// Before ES2020<br>const city = user && user.address && user.address.city;<br>``` | **ES2020**: Short-circuits if null/undefined. Returns `undefined` instead of throwing error. Combine with `??` for defaults. |
| **Logical AND (&&)** | Returns first falsy value or last value | Short-circuit evaluation; conditional execution | ```javascript<br>const result = true && "yes"; // "yes"<br>const check = null && "never"; // null<br>const value = 0 && "zero"; // 0<br><br>// Conditional execution<br>isLoggedIn && redirect();<br>user && sendEmail(user);<br>``` | **Short-circuits**: Stops at first falsy. Common in React: `{isVisible && <Component />}`. Not boolean, returns actual value. |
| **Logical OR (\|\|)** | Returns first truthy value or last value | Default values (but watch for 0, "") | ```javascript<br>const name = userName \|\| "Guest";<br>const value = 0 \|\| 100; // 100 (0 is falsy)<br>const text = "" \|\| "default"; // "default"<br>const final = false \|\| null \|\| "last"; // "last"<br>``` | **Issue**: Treats `0`, `""`, `false` as falsy. Use `??` for null/undefined only. Common for defaults before ES2020. |
| **typeof** | Returns string indicating operand type | Type checking; validation | ```javascript<br>typeof 42; // "number"<br>typeof "hello"; // "string"<br>typeof undefined; // "undefined"<br>typeof true; // "boolean"<br>typeof null; // "object" (JS bug!)<br>typeof function() {}; // "function"<br>typeof []; // "object"<br>``` | **Limitations**: `null` returns "object" (historical bug). Arrays return "object". Use `Array.isArray()` for arrays, `=== null` for null. |
| **instanceof** | Tests if object is instance of constructor | Checking object types; inheritance chains | ```javascript<br>[] instanceof Array; // true<br>({}) instanceof Object; // true<br>new Date() instanceof Date; // true<br>"text" instanceof String; // false (primitive)<br><br>class Dog extends Animal {}<br>const dog = new Dog();<br>dog instanceof Dog; // true<br>dog instanceof Animal; // true<br>``` | **Prototype check**: Checks constructor's prototype in object's chain. Doesn't work across different execution contexts (iframes). Primitives return false. |

---

## **SCOPE & CONTEXT**

| Term | Definition | When to Use | Example | Remarks |
|------|------------|-------------|---------|---------|
| **Global Scope** | Variables accessible from anywhere in code | Avoid when possible; only for truly global data | ```javascript<br>var globalVar = "accessible everywhere";<br>window.globalName = "also global";<br><br>function test() {<br>  console.log(globalVar); // works<br>}<br><br>if (true) {<br>  console.log(globalVar); // works<br>}<br>``` | **Avoid pollution**: Global variables can be overwritten. Use modules, IIFE, or let/const in blocks. In browsers: `window.x`, in Node: `global.x`. |
| **Function Scope** | Variables only accessible within function | Encapsulation; private variables | ```javascript<br>function myFunc() {<br>  var local = "only here";<br>  let alsoLocal = "block scoped";<br><br>  if (true) {<br>    var stillLocal = "function scoped";<br>    let blockOnly = "block scoped";<br>  }<br>  console.log(stillLocal); // works<br>  // console.log(blockOnly); // Error<br>}<br>// console.log(local); // Error<br>``` | **var behavior**: `var` is function-scoped, not block-scoped. This is why `let` and `const` were introduced. |
| **Block Scope** | Variables limited to {} block (let/const only) | Modern default; loop variables; conditionals | ```javascript<br>if (true) {<br>  let blockVar = "inside";<br>  const alsoBlock = "inside";<br>  var notBlock = "function scoped";<br>}<br>// console.log(blockVar); // Error<br>console.log(notBlock); // works<br><br>for (let i = 0; i < 3; i++) {<br>  console.log(i); // 0, 1, 2<br>}<br>// console.log(i); // Error<br>``` | **ES6 standard**: `let` and `const` are block-scoped. Prevents common bugs with loops and conditionals. Safer than function scope. |
| **Lexical Scope** | Inner functions access outer function variables | Understanding closures; variable resolution | ```javascript<br>function outer() {<br>  const x = 10;<br><br>  function inner() {<br>    const y = 20;<br>    console.log(x); // 10 (lexical access)<br>    console.log(y); // 20<br>  }<br><br>  inner();<br>  // console.log(y); // Error<br>}<br>``` | **Static scope**: Determined at write-time, not runtime. Foundation of closures. Inner functions "remember" outer scope. |
| **Hoisting** | Variable/function declarations moved to top | Understanding var behavior; interview questions | ```javascript<br>console.log(x); // undefined (not error)<br>var x = 5;<br><br>sayHi(); // works!<br>function sayHi() {<br>  console.log("Hi");<br>}<br><br>// console.log(y); // Error (TDZ)<br>let y = 10;<br>``` | **var quirk**: Declarations hoisted, not initializations. Function declarations fully hoisted. `let`/`const` have TDZ. Source of bugs. |
| **TDZ** | Temporal Dead Zone - time before let/const initialization | Understanding let/const; avoiding hoisting bugs | ```javascript<br>// TDZ starts<br>console.log(x); // ReferenceError<br>console.log(y); // ReferenceError<br><br>let x = 5; // TDZ ends for x<br>const y = 10; // TDZ ends for y<br><br>console.log(x); // 5<br>console.log(y); // 10<br>``` | **Safety feature**: Prevents accessing before initialization. Makes let/const safer than var. TDZ exists from block start to declaration. |
| **call()** | Invokes function with specific this and arguments | Borrowing methods; explicit context setting | ```javascript<br>function greet(greeting, punctuation) {<br>  return `${greeting}, ${this.name}${punctuation}`;<br>}<br><br>const user = { name: "Alice" };<br>greet.call(user, "Hello", "!"); // "Hello, Alice!"<br><br>// Borrowing methods<br>const arrayLike = { 0: 'a', 1: 'b', length: 2 };<br>Array.prototype.slice.call(arrayLike);<br>``` | **Explicit binding**: Sets `this` manually. Takes arguments individually. Useful for borrowing methods, binding context. |
| **apply()** | Like call() but arguments as array | When args are in array; Math.max with arrays | ```javascript<br>function sum(a, b, c) {<br>  return a + b + c;<br>}<br><br>const numbers = [1, 2, 3];<br>sum.apply(null, numbers); // 6<br><br>// Math.max with array<br>const max = Math.max.apply(null, [5, 10, 3]);<br><br>// Modern alternative: spread<br>const max2 = Math.max(...[5, 10, 3]);<br>``` | **Array arguments**: Only difference from `call()` is argument format. Spread operator often better now. Still useful for dynamic argument lists. |
| **bind()** | Creates new function with bound this context | Event handlers; React class methods; partial application | ```javascript<br>const obj = { name: "Bob" };<br><br>function greet(greeting) {<br>  return `${greeting}, ${this.name}`;<br>}<br><br>const boundGreet = greet.bind(obj);<br>boundGreet("Hi"); // "Hi, Bob"<br><br>// Partial application<br>const add = (a, b) => a + b;<br>const add5 = add.bind(null, 5);<br>add5(3); // 8<br>``` | **Returns new function**: Permanently binds `this`. Can pre-fill arguments (partial application). Common in React class components. |

---

## **ARRAY METHODS**

| Term | Definition | When to Use | Example | Remarks |
|------|------------|-------------|---------|---------|
| **map()** | Transforms each element, returns new array | Transforming data; rendering lists in UI | ```javascript<br>const nums = [1, 2, 3];<br>const doubled = nums.map(n => n * 2);<br>// [2, 4, 6]<br><br>const users = data.map(user => ({<br>  id: user.id,<br>  name: user.fullName,<br>  email: user.contact.email<br>}));<br>``` | **Pure function**: Doesn't modify original. Returns same length array. Use for transformations. Common in React for rendering lists. |
| **filter()** | Creates new array with elements passing test | Removing items; searching; conditional display | ```javascript<br>const nums = [1, 2, 3, 4, 5, 6];<br>const evens = nums.filter(n => n % 2 === 0);<br>// [2, 4, 6]<br><br>const adults = users.filter(user => {<br>  return user.age >= 18;<br>});<br><br>// Removing nulls<br>const clean = arr.filter(item => item != null);<br>``` | **Pure function**: Doesn't modify original. Can return shorter array. Returns empty array if nothing matches. |
| **reduce()** | Reduces array to single value via accumulator | Summing, grouping, transforming to object | ```javascript<br>// Sum<br>const sum = [1, 2, 3, 4].reduce((acc, n) => acc + n, 0);<br>// 10<br><br>// Grouping<br>const grouped = users.reduce((acc, user) => {<br>  const key = user.role;<br>  acc[key] = acc[key] || [];<br>  acc[key].push(user);<br>  return acc;<br>}, {});<br><br>// Flattening<br>const flat = [[1, 2], [3, 4]].reduce((acc, arr) => {<br>  return acc.concat(arr);<br>}, []);<br>``` | **Most powerful**: Can do what map/filter do. Initial value important! Without it, uses first element. Can return any type. |
| **forEach()** | Executes function for each element (no return) | Side effects only; when you don't need return value | ```javascript<br>const names = ["Alice", "Bob", "Charlie"];<br><br>names.forEach((name, index) => {<br>  console.log(`${index}: ${name}`);<br>});<br><br>// Cannot break/continue<br>names.forEach(name => {<br>  if (name === "Bob") return; // Only skips this iteration<br>  console.log(name);<br>});<br>``` | **Side effects**: Returns `undefined`. Can't break early. Use for effects, not transformations. Consider `for...of` if you need break/continue. |
| **find()** | Returns first element matching condition | Finding single item; search functionality | ```javascript<br>const users = [<br>  { id: 1, name: 'Alice' },<br>  { id: 2, name: 'Bob' },<br>  { id: 3, name: 'Charlie' }<br>];<br><br>const user = users.find(u => u.id === 2);<br>// { id: 2, name: 'Bob' }<br><br>const missing = users.find(u => u.id === 99);<br>// undefined<br>``` | **Returns first match**: Stops searching after first match. Returns `undefined` if not found. Use `findIndex()` to get index instead. |
| **some()** | Tests if at least one element passes test | Validation; checking conditions | ```javascript<br>const nums = [1, 3, 5, 8];<br>const hasEven = nums.some(n => n % 2 === 0);<br>// true<br><br>// Checking permissions<br>const hasAccess = permissions.some(p => {<br>  return p.role === 'admin';<br>});<br><br>// Empty array<br>[].some(n => n > 0); // false<br>``` | **Short-circuits**: Stops at first truthy. Returns boolean. Empty array returns `false`. Opposite of `every()`. |
| **every()** | Tests if all elements pass test | Validation; ensuring all items meet criteria | ```javascript<br>const nums = [2, 4, 6];<br>const allEven = nums.every(n => n % 2 === 0);<br>// true<br><br>// Validation<br>const allValid = users.every(user => {<br>  return user.age >= 18 && user.email;<br>});<br><br>// Empty array<br>[].every(n => n > 0); // true (vacuous truth)<br>``` | **Short-circuits**: Stops at first falsy. Returns boolean. Empty array returns `true` (by definition). Use for validation. |
| **slice()** | Extracts section of array (doesn't modify original) | Copying arrays; getting subset; pagination | ```javascript<br>const arr = [0, 1, 2, 3, 4];<br>const part = arr.slice(1, 4); // [1, 2, 3]<br>const copy = arr.slice(); // shallow copy<br>const last2 = arr.slice(-2); // [3, 4]<br><br>// Pagination<br>const page = items.slice(<br>  (pageNum - 1) * pageSize,<br>  pageNum * pageSize<br>);<br>``` | **Non-mutating**: Original unchanged. Negative indices count from end. End index exclusive. Use for copying, pagination. |
| **splice()** | Adds/removes elements (modifies original) | Inserting, removing, replacing items in place | ```javascript<br>const arr = [1, 2, 3, 4, 5];<br><br>// Remove 2 elements at index 2<br>arr.splice(2, 2); // returns [3, 4]<br>// arr is now [1, 2, 5]<br><br>// Insert at index 1<br>arr.splice(1, 0, 'a', 'b');<br>// arr is now [1, 'a', 'b', 2, 5]<br><br>// Replace<br>arr.splice(2, 1, 'x');<br>// arr is now [1, 'a', 'x', 2, 5]<br>``` | **Mutates original**: Returns removed elements. Versatile but destructive. Use `slice()` if you don't want mutation. |

---

## **ERROR HANDLING**

| Term | Definition | When to Use | Example | Remarks |
|------|------------|-------------|---------|---------|
| **try/catch** | Catches and handles runtime errors | Parsing JSON, API calls, risky operations | ```javascript<br>try {<br>  const data = JSON.parse(invalidJSON);<br>  processData(data);<br>} catch (error) {<br>  console.error("Parse error:", error.message);<br>  // Fallback behavior<br>  return defaultData;<br>}<br><br>// Async version<br>try {<br>  const response = await fetch('/api');<br>  const data = await response.json();<br>} catch (error) {<br>  handleError(error);<br>}<br>``` | **Synchronous**: Catches errors in try block. Doesn't catch errors in async callbacks. Use with async/await for async code. |
| **throw** | Manually throws custom error | Validation, enforcing contracts, custom errors | ```javascript<br>function divide(a, b) {<br>  if (b === 0) {<br>    throw new Error("Division by zero");<br>  }<br>  return a / b;<br>}<br><br>// Custom error<br>class ValidationError extends Error {<br>  constructor(message) {<br>    super(message);<br>    this.name = "ValidationError";<br>  }<br>}<br><br>throw new ValidationError("Invalid input");<br>``` | **Control flow**: Stops execution, jumps to catch. Can throw any value, but use Error objects. Custom errors enable specific handling. |
| **finally** | Always executes after try/catch (cleanup) | Closing connections, hiding loaders, cleanup | ```javascript<br>let loading = true;<br><br>try {<br>  const data = await fetchData();<br>  processData(data);<br>} catch (error) {<br>  handleError(error);<br>} finally {<br>  loading = false; // Always runs<br>  hideLoadingSpinner();<br>}<br><br>// Even with return<br>try {<br>  return result;<br>} finally {<br>  cleanup(); // Still runs!<br>}<br>``` | **Guaranteed execution**: Runs even if return, throw in try/catch. Perfect for cleanup. Runs before return value is returned. |
| **Error Object** | Built-in constructor for error instances | Creating meaningful errors; stack traces | ```javascript<br>const err = new Error("Something failed");<br>console.log(err.name); // "Error"<br>console.log(err.message); // "Something failed"<br>console.log(err.stack); // stack trace<br><br>// Built-in types<br>new TypeError("Wrong type");<br>new ReferenceError("Variable not defined");<br>new SyntaxError("Invalid syntax");<br><br>// Custom<br>class AppError extends Error {<br>  constructor(message, statusCode) {<br>    super(message);<br>    this.statusCode = statusCode;<br>  }<br>}<br>``` | **Rich information**: Contains message, stack trace, name. Extend Error for custom errors. Stack trace crucial for debugging. |

---

## **MODULES**

| Term | Definition | When to Use | Example | Remarks |
|------|------------|-------------|---------|---------|
| **import** | Imports exported values from other modules | Organizing code; reusing functions; dependencies | ```javascript<br>// Named imports<br>import { add, subtract } from './math.js';<br><br>// Default import<br>import React from 'react';<br><br>// Namespace import<br>import * as utils from './utils.js';<br><br>// Renaming<br>import { longName as short } from './module.js';<br><br>// Side effects only<br>import './styles.css';<br>``` | **ES6 modules**: Static imports (compile-time). Enables tree-shaking. File extension required in browsers. Top-level only (no conditional imports). |
| **export** | Makes values available to other modules | Sharing code between files; building libraries | ```javascript<br>// Named exports<br>export const PI = 3.14;<br>export function calculate() { }<br><br>// Export list<br>const a = 1;<br>const b = 2;<br>export { a, b };<br><br>// Re-exporting<br>export { func } from './other.js';<br>export * from './all.js';<br>``` | **Multiple exports**: Can have many named exports. Improves tree-shaking. One default + many named per file. |
| **default export** | Single main export per module | Main class/function from module; React components | ```javascript<br>// math.js<br>export default function add(a, b) {<br>  return a + b;<br>}<br><br>// or<br>function add(a, b) {<br>  return a + b;<br>}<br>export default add;<br><br>// app.js<br>import add from './math.js';<br>import myAdd from './math.js'; // any name works<br>``` | **One per module**: Can import with any name. Common for React components. Combine with named exports. |
| **named export** | Multiple exports from same module | Utilities, helper functions, constants | ```javascript<br>// utils.js<br>export const format = (str) => str.trim();<br>export const validate = (val) => val != null;<br>export const API_URL = 'https://api.example.com';<br><br>// app.js<br>import { format, validate, API_URL } from './utils.js';<br><br>// Import all<br>import * as utils from './utils.js';<br>utils.format('test');<br>``` | **Better for tree-shaking**: Import only what you need. Explicit names. Can have many per file. |

---

## **ADVANCED CONCEPTS**

| Term | Definition | When to Use | Example | Remarks |
|------|------------|-------------|---------|---------|
| **Currying** | Transform function to take args one at a time | Partial application, function composition, reusability | ```javascript<br>// Basic currying<br>const add = a => b => a + b;<br>const add5 = add(5);<br>add5(3); // 8<br><br>// Practical example<br>const greet = greeting => name => {<br>  return `${greeting}, ${name}!`;<br>};<br><br>const sayHello = greet("Hello");<br>const sayHi = greet("Hi");<br><br>sayHello("Alice"); // "Hello, Alice!"<br>sayHi("Bob"); // "Hi, Bob!"<br>``` | **Functional programming**: Enables partial application. Creates reusable, specialized functions. Common in Redux, React hooks. |
| **Memoization** | Cache function results for performance | Expensive calculations, recursive functions, optimization | ```javascript<br>const memoize = (fn) => {<br>  const cache = new Map();<br>  return (...args) => {<br>    const key = JSON.stringify(args);<br>    if (cache.has(key)) {<br>      return cache.get(key);<br>    }<br>    const result = fn(...args);<br>    cache.set(key, result);<br>    return result;<br>  };<br>};<br><br>const expensiveCalc = memoize((n) => {<br>  console.log('Computing...');<br>  return n * n;<br>});<br><br>expensiveCalc(5); // Computing... 25<br>expensiveCalc(5); // 25 (cached)<br>``` | **Trade-off**: Memory for speed. Great for pure functions. Watch memory usage with large caches. React.useMemo uses this pattern. |
| **Debouncing** | Delay function execution until pause | Search input, window resize, form validation | ```javascript<br>function debounce(fn, delay) {<br>  let timer;<br>  return (...args) => {<br>    clearTimeout(timer);<br>    timer = setTimeout(() => {<br>      fn(...args);<br>    }, delay);<br>  };<br>}<br><br>// Usage<br>const searchAPI = debounce((query) => {<br>  fetch(`/api/search?q=${query}`);<br>}, 300);<br><br>input.addEventListener('input', (e) => {<br>  searchAPI(e.target.value);<br>});<br>``` | **Wait for pause**: Only executes after user stops. Reduces API calls. Common for search, resize. Use 300ms for typing, 150ms for UI. |
| **Throttling** | Limit function execution rate | Scroll events, mousemove, rate limiting | ```javascript<br>function throttle(fn, limit) {<br>  let inThrottle;<br>  return (...args) => {<br>    if (!inThrottle) {<br>      fn(...args);<br>      inThrottle = true;<br>      setTimeout(() => {<br>        inThrottle = false;<br>      }, limit);<br>    }<br>  };<br>}<br><br>// Usage<br>const handleScroll = throttle(() => {<br>  console.log('Scrolling...');<br>}, 1000);<br><br>window.addEventListener('scroll', handleScroll);<br>``` | **Regular intervals**: Executes at most once per period. Different from debounce (which waits for pause). Better for scroll, mouse events. |
| **Generator** | Function that can pause and resume | Iterating sequences, async flow control, lazy evaluation | ```javascript<br>function* numberGen() {<br>  yield 1;<br>  yield 2;<br>  yield 3;<br>}<br><br>const gen = numberGen();<br>console.log(gen.next()); // { value: 1, done: false }<br>console.log(gen.next()); // { value: 2, done: false }<br>console.log(gen.next()); // { value: 3, done: false }<br>console.log(gen.next()); // { value: undefined, done: true }<br><br>// Infinite sequence<br>function* idGenerator() {<br>  let id = 1;<br>  while (true) {<br>    yield id++;<br>  }<br>}<br>``` | **Lazy evaluation**: Values generated on demand. Memory efficient. Can pause/resume. Foundation for async iterators. Redux-Saga uses generators. |
| **Iterator** | Object defining sequence and return value | Custom iteration logic, making objects iterable | ```javascript<br>const iterable = {<br>  [Symbol.iterator]() {<br>    let i = 0;<br>    const data = [1, 2, 3];<br>    return {<br>      next: () => ({<br>        value: data[i],<br>        done: i++ >= data.length<br>      })<br>    };<br>  }<br>};<br><br>for (const val of iterable) {<br>  console.log(val); // 1, 2, 3<br>}<br><br>// Spread works too<br>const arr = [...iterable];<br>``` | **Protocol**: Makes objects work with for...of, spread. Arrays, strings, Maps, Sets are iterable. Custom iterables enable lazy evaluation. |
| **Proxy** | Intercepts operations on objects | Validation, logging, reactive systems, data binding | ```javascript<br>const handler = {<br>  get: (obj, prop) => {<br>    console.log(`Getting ${prop}`);<br>    return prop in obj ? obj[prop] : 'N/A';<br>  },<br>  set: (obj, prop, value) => {<br>    console.log(`Setting ${prop} to ${value}`);<br>    if (prop === 'age' && typeof value !== 'number') {<br>      throw new TypeError('Age must be number');<br>    }<br>    obj[prop] = value;<br>    return true;<br>  }<br>};<br><br>const user = new Proxy({ name: 'Alice' }, handler);<br>user.age = 30; // Setting age to 30<br>console.log(user.age); // Getting age, 30<br>``` | **Meta-programming**: Intercept object operations. Vue 3 uses Proxies for reactivity. 13 trap types available. Performance cost. |
| **Reflect** | Built-in object for interceptable operations | Inside Proxy handlers, safer property access | ```javascript<br>const obj = { name: 'Bob', age: 30 };<br><br>// Instead of direct access<br>Reflect.get(obj, 'name'); // 'Bob'<br>Reflect.set(obj, 'age', 31); // true<br>Reflect.has(obj, 'name'); // true<br>Reflect.deleteProperty(obj, 'age'); // true<br><br>// With Proxy<br>const handler = {<br>  get: (target, prop) => {<br>    console.log(`Getting ${prop}`);<br>    return Reflect.get(target, prop);<br>  }<br>};<br>``` | **Companion to Proxy**: Same methods as Proxy traps. Returns booleans for operations (safer). Use in Proxy handlers for default behavior. |

---

## **COMMON PATTERNS & BEST PRACTICES**

| Pattern | Definition | When to Use | Example | Remarks |
|---------|------------|-------------|---------|---------|
| **Method Chaining** | Return 'this' to allow consecutive method calls | Building fluent APIs, jQuery-style operations | ```javascript<br>class Calculator {<br>  constructor() {<br>    this.value = 0;<br>  }<br><br>  add(n) {<br>    this.value += n;<br>    return this;<br>  }<br><br>  multiply(n) {<br>    this.value *= n;<br>    return this;<br>  }<br><br>  getValue() {<br>    return this.value;<br>  }<br>}<br><br>const result = new Calculator()<br>  .add(5)<br>  .multiply(2)<br>  .add(3)<br>  .getValue(); // 13<br>``` | **Fluent interface**: Makes code readable. Popular in libraries (jQuery, Lodash). Return `this` from mutator methods. Don't chain too deeply. |
| **Object.assign()** | Copy properties from sources to target | Shallow cloning, merging objects, default options | ```javascript<br>const defaults = {<br>  theme: 'light',<br>  size: 'md',<br>  animations: true<br>};<br><br>const userSettings = {<br>  theme: 'dark',<br>  language: 'en'<br>};<br><br>const config = Object.assign({}, defaults, userSettings);<br>// { theme: 'dark', size: 'md', animations: true, language: 'en' }<br>``` | **Shallow copy**: Doesn't deep clone nested objects. Spread operator `{...obj}` is cleaner. Useful for merging configs. |
| **Object.keys()** | Returns array of object's keys | Iterating object properties, validation | ```javascript<br>const user = {<br>  name: 'Alice',<br>  age: 30,<br>  email: 'alice@example.com'<br>};<br><br>Object.keys(user); // ['name', 'age', 'email']<br><br>// Counting properties<br>const propCount = Object.keys(user).length; // 3<br><br>// Iterating<br>Object.keys(user).forEach(key => {<br>  console.log(`${key}: ${user[key]}`);<br>});<br>``` | **Own properties only**: Doesn't include inherited properties. Returns strings (even for array indices). Use `Object.entries()` for key-value pairs. |
| **Object.values()** | Returns array of object's values | Getting all values, summing object properties | ```javascript<br>const scores = {<br>  math: 90,<br>  science: 85,<br>  english: 88<br>};<br><br>Object.values(scores); // [90, 85, 88]<br><br>// Calculate average<br>const total = Object.values(scores).reduce((a, b) => a + b, 0);<br>const avg = total / Object.values(scores).length;<br>// 87.67<br><br>// Check if all values meet criteria<br>const allPassing = Object.values(scores).every(s => s >= 60);<br>``` | **Values only**: No keys. Order not guaranteed (though usually insertion order in modern JS). Useful with array methods. |
| **Object.entries()** | Returns array of [key, value] pairs | Converting to Map, iterating with both key and value | ```javascript<br>const user = {<br>  name: 'Bob',<br>  age: 25,<br>  role: 'admin'<br>};<br><br>Object.entries(user);<br>// [['name', 'Bob'], ['age', 25], ['role', 'admin']]<br><br>// Iterating with destructuring<br>for (const [key, value] of Object.entries(user)) {<br>  console.log(`${key}: ${value}`);<br>}<br><br>// Converting to Map<br>const map = new Map(Object.entries(user));<br><br>// Filtering object<br>const filtered = Object.fromEntries(<br>  Object.entries(user).filter(([key, val]) => {<br>    return typeof val === 'string';<br>  })<br>);<br>``` | **Most versatile**: Get both keys and values. Works great with `for...of`. Use with `Object.fromEntries()` to reconstruct object. |
| **Array.from()** | Creates array from iterable or array-like | Converting NodeList, strings, Sets to arrays | ```javascript<br>// String to array<br>Array.from('hello'); // ['h', 'e', 'l', 'l', 'o']<br><br>// Set to array<br>const uniqueNums = Array.from(new Set([1, 2, 2, 3]));<br>// [1, 2, 3]<br><br>// NodeList to array<br>const divs = Array.from(document.querySelectorAll('div'));<br><br>// With mapping function<br>Array.from({ length: 5 }, (v, i) => i * 2);<br>// [0, 2, 4, 6, 8]<br><br>// Array-like to array<br>function sum() {<br>  const args = Array.from(arguments);<br>  return args.reduce((a, b) => a + b, 0);<br>}<br>``` | **Versatile**: Works with any iterable or array-like. Second parameter is map function. Spread `[...iterable]` is shorter for iterables. |
| **Template Literals** | String interpolation with embedded expressions | Dynamic strings, multi-line text, HTML templates | ```javascript<br>const name = 'World';<br>const greeting = `Hello, ${name}!`;<br><br>// Multi-line<br>const html = `<br>  <div class="card"><br>    <h2>${title}</h2><br>    <p>${description}</p><br>  </div><br>`;<br><br>// Expressions<br>const price = `Total: ${(quantity * unitPrice).toFixed(2)}`;<br><br>// Tagged templates<br>function highlight(strings, ...values) {<br>  return strings.reduce((result, str, i) => {<br>    return result + str + (values[i] ? `<mark>${values[i]}</mark>` : '');<br>  }, '');<br>}<br><br>const text = highlight`Hello ${name}, you have ${count} messages`;<br>``` | **ES6 standard**: Cleaner than concatenation. Preserves whitespace. Tagged templates enable custom processing (styled-components uses this). |
| **Short-Circuit Evaluation** | Using && and \|\| for conditional logic | Default values, conditional execution, guards | ```javascript<br>// Default values<br>const displayName = userName \|\| 'Guest';<br><br>// Conditional execution<br>isLoggedIn && renderDashboard();<br>user && user.sendEmail();<br><br>// Guard clauses<br>function processUser(user) {<br>  if (!user) return null;<br>  return user.name.toUpperCase();<br>}<br><br>// Chain of defaults<br>const value = input \|\| localStorage.get('key') \|\| DEFAULT;<br><br>// React pattern<br>return (<br>  <div><br>    {isLoading && <Spinner />}<br>    {error && <ErrorMessage />}<br>    {data && <DataDisplay data={data} />}<br>  </div><br>);<br>``` | **Concise conditionals**: Common in React. `&&` stops at first falsy, `||` at first truthy. Watch for falsy values (0, "", false). Use `??` for null/undefined only. |
| **Destructuring with Defaults** | Combining destructuring with default values | Function parameters, API responses with optional fields | ```javascript<br>// Object destructuring with defaults<br>function createUser({<br>  name,<br>  age = 18,<br>  role = 'user',<br>  active = true<br>}) {<br>  return { name, age, role, active };<br>}<br><br>createUser({ name: 'Alice' });<br>// { name: 'Alice', age: 18, role: 'user', active: true }<br><br>// Nested with defaults<br>function processConfig({<br>  api: {<br>    url = 'https://api.example.com',<br>    timeout = 5000<br>  } = {}<br>}) {<br>  // url and timeout have defaults<br>}<br><br>// Array destructuring with defaults<br>const [first = 'default', second = 'default'] = arr;<br>``` | **Robust code**: Handles missing properties gracefully. Common in React props. Nested defaults need careful syntax. |
| **Optional Chaining with Nullish Coalescing** | Combining ?. and ?? for safe access with defaults | API responses, user input, configuration | ```javascript<br>// Safe nested access with default<br>const city = user?.address?.city ?? 'Unknown';<br><br>// Method calls<br>const result = obj?.method?.() ?? defaultValue;<br><br>// Array access<br>const firstItem = data?.items?.[0] ?? 'No items';<br><br>// Before ES2020<br>const city = (user && user.address && user.address.city) \|\| 'Unknown';<br><br>// Complex example<br>const config = {<br>  serverUrl: apiConfig?.servers?.[0]?.url ?? DEFAULT_URL,<br>  timeout: settings?.network?.timeout ?? 5000,<br>  retries: options?.retry?.count ?? 3<br>};<br>``` | **Modern pattern**: Combines ES2020 features. More reliable than `||` for defaults. Short-circuits on null/undefined. Cleaner than long conditionals. |

---

## **ES6+ FEATURES QUICK REFERENCE**

| Feature | Purpose | When to Use | Example | Remarks |
|---------|---------|-------------|---------|---------|
| **let/const** | Block-scoped variables | Always (replace var) | ```javascript<br>const MAX = 100; // won't change<br>let count = 0; // will change<br><br>if (true) {<br>  let blockScoped = 'local';<br>  const alsoBlock = 'local';<br>}<br>// console.log(blockScoped); // Error<br>``` | **Default choice**: Use `const` by default, `let` when reassignment needed. Never use `var`. |
| **Arrow Functions** | Concise function syntax | Callbacks, short functions, lexical this | ```javascript<br>// One parameter<br>const double = x => x * 2;<br><br>// Multiple parameters<br>const add = (a, b) => a + b;<br><br>// Block body<br>const complex = (x) => {<br>  const result = x * 2;<br>  return result + 1;<br>};<br><br>// Returning object (wrap in parens)<br>const makeUser = name => ({ name, active: true });<br>``` | **Lexical this**: Inherits `this` from parent. No `arguments` object. Can't be constructor. |
| **Spread/Rest** | Expand/collect elements | Copying, merging, function args | ```javascript<br>// Spread in arrays<br>const merged = [...arr1, ...arr2];<br>const copy = [...original];<br><br>// Spread in objects<br>const updated = { ...user, age: 31 };<br><br>// Rest in functions<br>function sum(...numbers) {<br>  return numbers.reduce((a, b) => a + b, 0);<br>}<br><br>// Rest in destructuring<br>const [first, ...rest] = [1, 2, 3, 4];<br>const { name, ...otherProps } = user;<br>``` | **Versatile**: Context determines meaning. Rest must be last parameter. Shallow copy only. |
| **Map/Set** | Better data structures | Unique values, key-value with any key type | ```javascript<br>// Set - unique values<br>const unique = new Set([1, 2, 2, 3]); // {1, 2, 3}<br>unique.add(4);<br>unique.has(2); // true<br>unique.size; // 4<br><br>// Map - any key type<br>const map = new Map();<br>map.set('name', 'Alice');<br>map.set(obj, 'value'); // object as key!<br>map.get('name'); // 'Alice'<br>map.size; // 2<br><br>// Iteration<br>for (const [key, value] of map) {<br>  console.log(key, value);<br>}<br>``` | **Better than objects**: Map preserves key order, allows any key type. Set ensures uniqueness. Both iterable. |
| **for...of** | Iterate over values | Arrays, strings, iterables | ```javascript<br>// Array<br>for (const item of [1, 2, 3]) {<br>  console.log(item); // 1, 2, 3<br>}<br><br>// String<br>for (const char of 'hello') {<br>  console.log(char); // h, e, l, l, o<br>}<br><br>// Map<br>for (const [key, value] of map) {<br>  console.log(key, value);<br>}<br><br>// Can use break/continue<br>for (const item of items) {<br>  if (item > 10) break;<br>  console.log(item);<br>}<br>``` | **Modern iteration**: Cleaner than `for` loop. Gets values, not indices. Works with any iterable. Use `for...in` for object keys (but prefer `Object.keys()`). |

---

## **DEBUGGING & TESTING**

| Tool/Method | Purpose | When to Use | Example | Remarks |
|-------------|---------|-------------|---------|-------------|
| **console.log()** | Print values to console | Basic debugging, checking values | ```javascript<br>console.log('value:', x);<br><br>// Multiple values<br>console.log('User:', user, 'Count:', count);<br><br>// Object shorthand<br>console.log({ user, posts, comments });<br><br>// Styled output<br>console.log('%c Important!', 'color: red; font-size: 20px');<br>``` | **Most common**: Simple but effective. Use object shorthand for multiple variables. Remove before production. |
| **console.table()** | Display arrays/objects as table | Viewing structured data | ```javascript<br>const users = [<br>  { id: 1, name: 'Alice', age: 30 },<br>  { id: 2, name: 'Bob', age: 25 },<br>  { id: 3, name: 'Charlie', age: 35 }<br>];<br><br>console.table(users);<br><br>// Select columns<br>console.table(users, ['name', 'age']);<br>``` | **Readable format**: Great for arrays of objects. Shows in tabular format. More readable than log. |
| **debugger** | Pause execution for debugging | Complex debugging, inspecting state | ```javascript<br>function calculate(x, y) {<br>  debugger; // Execution pauses here<br>  const result = x * y;<br>  return result + 10;<br>}<br><br>// Conditional debugging<br>if (user.role === 'admin') {<br>  debugger;<br>}<br>``` | **Powerful**: Pauses execution in DevTools. Inspect variables, step through code. Remember to remove before production. |
| **console.assert()** | Log if assertion fails | Validation, testing assumptions | ```javascript<br>console.assert(x > 0, 'x must be positive');<br>console.assert(Array.isArray(data), 'data must be array');<br><br>function divide(a, b) {<br>  console.assert(b !== 0, 'Division by zero!');<br>  return a / b;<br>}<br>``` | **Quick checks**: Only logs if assertion fails. Doesn't stop execution. Good for development checks. |
| **console.trace()** | Show stack trace | Tracking function calls | ```javascript<br>function a() {<br>  b();<br>}<br><br>function b() {<br>  c();<br>}<br><br>function c() {<br>  console.trace('How did we get here?');<br>}<br><br>a(); // Shows: c -> b -> a<br>``` | **Call stack**: Shows function call chain. Useful for understanding code flow. Helps find where function is called from. |
| **Performance Measurement** | Measure execution time | Optimization, finding bottlenecks | ```javascript<br>// console.time/timeEnd<br>console.time('myOperation');<br>expensiveOperation();<br>console.timeEnd('myOperation'); // myOperation: 234ms<br><br>// performance.now()<br>const start = performance.now();<br>doSomething();<br>const end = performance.now();<br>console.log(`Took ${end - start}ms`);<br><br>// Multiple measurements<br>console.time('fetch');<br>await fetchData();<br>console.timeEnd('fetch');<br><br>console.time('process');<br>processData();<br>console.timeEnd('process');<br>``` | **Performance profiling**: Identifies slow operations. Use `performance.now()` for precise timing. Browser DevTools have advanced profilers. |

---

## **COMMON GOTCHAS & PITFALLS**

| Issue | Why It Happens | Solution | Example |
|-------|----------------|----------|---------|
| **Type Coercion** | `==` performs type conversion | Always use `===` | ```javascript<br>// Bad<br>0 == false; // true<br>"" == false; // true<br><br>// Good<br>0 === false; // false<br>"" === false; // false<br>``` |
| **`this` binding** | `this` depends on how function is called | Use arrow functions or `.bind()` | ```javascript<br>// Problem<br>const obj = {<br>  name: 'Test',<br>  greet: function() {<br>    setTimeout(function() {<br>      console.log(this.name); // undefined<br>    }, 100);<br>  }<br>};<br><br>// Solution 1: Arrow function<br>greet: function() {<br>  setTimeout(() => {<br>    console.log(this.name); // works!<br>  }, 100);<br>}<br><br>// Solution 2: bind<br>setTimeout(function() {<br>  console.log(this.name);<br>}.bind(this), 100);<br>``` |
| **Array/Object Mutation** | References, not copies | Use spread or proper copy methods | ```javascript<br>// Problem<br>const original = [1, 2, 3];<br>const copy = original;<br>copy.push(4);<br>console.log(original); // [1, 2, 3, 4] - mutated!<br><br>// Solution<br>const copy = [...original]; // shallow copy<br>const deepCopy = structuredClone(original); // deep copy<br>``` |
| **Floating Point** | Binary representation imprecision | Use toFixed() or libraries | ```javascript<br>// Problem<br>0.1 + 0.2; // 0.30000000000000004<br><br>// Solution<br>(0.1 + 0.2).toFixed(2); // "0.30"<br>Math.round((0.1 + 0.2) * 100) / 100; // 0.3<br>``` |
| **Async/Await Errors** | Forgot try/catch or await | Always handle errors | ```javascript<br>// Problem<br>async function getData() {<br>  const data = await fetch('/api'); // unhandled rejection<br>}<br><br>// Solution<br>async function getData() {<br>  try {<br>    const data = await fetch('/api');<br>    return data;<br>  } catch (error) {<br>    console.error('Failed:', error);<br>    throw error;<br>  }<br>}<br>``` |

---

## **PERFORMANCE OPTIMIZATION**

| Technique | Purpose | When to Use | Example | Remarks |
|-----------|---------|-------------|---------|---------|
| **Lazy Loading** | Load resources on demand | Images, modules, routes, large data | ```javascript<br>// Dynamic import<br>const module = await import('./heavy-module.js');<br><br>// React lazy<br>const LazyComponent = React.lazy(() => {<br>  return import('./Component.js');<br>});<br><br>// Image lazy loading<br><img loading="lazy" src="image.jpg" /><br>``` | **Improves initial load**: Load only what's needed. Reduces bundle size. Common in SPAs. Browser native for images. |
| **Web Workers** | Run scripts in background thread | Heavy computations, data processing | ```javascript<br>// main.js<br>const worker = new Worker('worker.js');<br><br>worker.postMessage({ data: largeArray });<br><br>worker.onmessage = (e) => {<br>  console.log('Result:', e.data);<br>};<br><br>// worker.js<br>self.onmessage = (e) => {<br>  const result = processData(e.data);<br>  self.postMessage(result);<br>};<br>``` | **Parallel processing**: Doesn't block UI. No DOM access. Use for CPU-intensive tasks. Overhead in data transfer. |
| **requestAnimationFrame** | Schedule visual updates | Animations, smooth scrolling | ```javascript<br>function animate() {<br>  // Update animation state<br>  element.style.transform = `translateX(${x}px)`;<br>  x += 1;<br><br>  if (x < 500) {<br>    requestAnimationFrame(animate);<br>  }<br>}<br><br>requestAnimationFrame(animate);<br>``` | **60 FPS**: Syncs with browser refresh. Pauses in inactive tabs. Better than setInterval for animations. |

---

## **QUICK TIPS & BEST PRACTICES**

**🎯 Always:**
- Use `const` by default, `let` when needed, never `var`
- Use `===` instead of `==`
- Prefer arrow functions for callbacks
- Embrace destructuring and spread operators
- Handle async operations with try/catch
- Avoid mutating objects/arrays directly
- Use optional chaining `?.` and nullish coalescing `??`
- Write pure functions when possible

**⚠️ Avoid:**
- Global variables
- Callback hell (use Promises/async-await)
- Modifying built-in prototypes
- Using `eval()` or `with`
- Deep nesting (keep functions small)
- Magic numbers (use named constants)

**📚 Understanding Key Concepts:**
- **Closures**: Foundation of many JS patterns
- **Scope & Context**: Know the difference
- **Event Loop**: Critical for async understanding
- **Prototypal Inheritance**: How JS objects work
- **Hoisting**: Why var behaves strangely
- **this binding**: Context in different scenarios

**🔧 Development Tools:**
- Browser DevTools (Chrome, Firefox)
- ESLint for code quality
- Prettier for formatting
- Jest/Vitest for testing
- Webpack/Vite for bundling

**📖 Further Learning:**
- **MDN Web Docs**: Comprehensive JavaScript reference
- **JavaScript.info**: Modern tutorial with depth
- **You Don't Know JS**: Deep dive book series
- Practice with real projects to solidify concepts
- Read source code of popular libraries

---

**Pro Tip**: Bookmark this comprehensive guide for quick JavaScript reference! 🚀

**Last Updated**: 2025 - Includes all modern JavaScript features through ES2024