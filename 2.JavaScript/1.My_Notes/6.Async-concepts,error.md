
# Async programming 
 
* types of methods used in JavaScript
 1.Callback function.
 2.Promise
 3.Async
 4.Async and Await



---

# ⚙️ **Asynchronous Methods in JavaScript — Clear Notes**

---

### 🔹 **1. Callback Function**

**Definition:**
A function passed to another function to run after a task completes.

**Limitations (with reasons):**

1. **Callback Hell** → When many async operations depend on each other, callbacks get nested deeply — code becomes hard to follow.
2. **Poor Readability** → Logic flows from right to left (nested), not top to bottom.
3. **No Built-in Error Handling** → You must manually pass and handle error parameters.
4. **Difficult Debugging** → Hard to trace where a problem occurred inside multiple nested functions.
5. **Uncontrolled Flow** → Managing order or cancellation of async operations is complex.

---

### 🔹 **2. Promise**

**Definition:**
Represents a future value of an async operation (resolved or rejected).

**Limitations (with reasons):**

1. **Long Chaining** → Many `.then()` calls make code lengthy; logic gets stretched vertically.
2. **Manual Sequencing** → You must chain Promises carefully for tasks that depend on each other.
3. **Error Propagation** → If `.catch()` is missed or misplaced, errors go unnoticed.
4. **Learning Curve** → Understanding resolve/reject and chaining can confuse beginners.
5. **Limited Readability** → For complex async flows, still looks mechanical compared to async/await.

---

### 🔹 **3. Async Function**

**Definition:**
A function declared with `async` that automatically returns a Promise.

**Limitations (with reasons):**

1. **Needs `await` or `.then()`** → Because async functions return Promises, you must explicitly wait or handle the result.
2. **Local Pause Only** → `await` pauses execution **inside** the async function, not the whole program.
3. **Error Handling Required** → Errors inside async functions must be caught with `try...catch`, otherwise they become unhandled Promise rejections.
4. **Flow Confusion** → Mixing sync and async logic may cause unexpected order of execution.

---

### 🔹 **4. Async & Await**

**Definition:**
Built on top of Promises; allows writing asynchronous code that looks synchronous.

**Limitations (with reasons):**

1. **Sequential Execution by Default** → Each `await` waits for the previous one, slowing performance in parallel tasks.
2. **Needs Async Wrapper** → `await` can only be used inside functions marked `async`.
3. **Performance Risk in Loops** → Awaiting inside loops runs one at a time instead of all together — inefficient.
4. **Error Handling Required** → Must wrap in `try...catch` or else unhandled Promise rejection occurs.
5. **Not Ideal for Parallel Tasks** → You still need `Promise.all()` to run multiple async operations together.

---

✅ **Summary Insight:**

* **Callbacks** → simple but messy.
* **Promises** → structured but still verbose.
* **Async functions** → easier but still depend on Promises.
* **Async/Await** → cleanest syntax but can slow down parallel tasks if used carelessly.

---

Would you like me to add a **real-world analogy** (like ordering food → callback vs promise vs async/await) to make the differences feel intuitive?



* **Promise** → part of **ECMAScript (JS language)**, introduced in **ES6 (2015)** for async handling.
* **`fetch()`** → part of **browser Web APIs written in c++ in their browsers, not ECMAScript.
* Before `fetch()`, browsers used **`XMLHttpRequest` (XHR)** for network requests.
* `fetch()` is in chrome uses **Promise** under the hood to return async results.
----------------------------------------
