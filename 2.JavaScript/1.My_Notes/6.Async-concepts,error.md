
# Async programming 
 
* types of methods used in JavaScript
 1.Callback function.
 2.Promise
 3.Async
 4.Async and Await



---

# âš™ï¸ **Asynchronous Methods in JavaScript â€” Clear Notes**

---

### ğŸ”¹ **1. Callback Function**

**Definition:**
A function passed to another function to run after a task completes.

**Limitations (with reasons):**

1. **Callback Hell** â†’ When many async operations depend on each other, callbacks get nested deeply â€” code becomes hard to follow.
2. **Poor Readability** â†’ Logic flows from right to left (nested), not top to bottom.
3. **No Built-in Error Handling** â†’ You must manually pass and handle error parameters.
4. **Difficult Debugging** â†’ Hard to trace where a problem occurred inside multiple nested functions.
5. **Uncontrolled Flow** â†’ Managing order or cancellation of async operations is complex.

---

### ğŸ”¹ **2. Promise**

**Definition:**
Represents a future value of an async operation (resolved or rejected).

**Limitations (with reasons):**

1. **Long Chaining** â†’ Many `.then()` calls make code lengthy; logic gets stretched vertically.
2. **Manual Sequencing** â†’ You must chain Promises carefully for tasks that depend on each other.
3. **Error Propagation** â†’ If `.catch()` is missed or misplaced, errors go unnoticed.
4. **Learning Curve** â†’ Understanding resolve/reject and chaining can confuse beginners.
5. **Limited Readability** â†’ For complex async flows, still looks mechanical compared to async/await.

---

### ğŸ”¹ **3. Async Function**

**Definition:**
A function declared with `async` that automatically returns a Promise.

**Limitations (with reasons):**

1. **Needs `await` or `.then()`** â†’ Because async functions return Promises, you must explicitly wait or handle the result.
2. **Local Pause Only** â†’ `await` pauses execution **inside** the async function, not the whole program.
3. **Error Handling Required** â†’ Errors inside async functions must be caught with `try...catch`, otherwise they become unhandled Promise rejections.
4. **Flow Confusion** â†’ Mixing sync and async logic may cause unexpected order of execution.

---

### ğŸ”¹ **4. Async & Await**

**Definition:**
Built on top of Promises; allows writing asynchronous code that looks synchronous.

**Limitations (with reasons):**

1. **Sequential Execution by Default** â†’ Each `await` waits for the previous one, slowing performance in parallel tasks.
2. **Needs Async Wrapper** â†’ `await` can only be used inside functions marked `async`.
3. **Performance Risk in Loops** â†’ Awaiting inside loops runs one at a time instead of all together â€” inefficient.
4. **Error Handling Required** â†’ Must wrap in `try...catch` or else unhandled Promise rejection occurs.
5. **Not Ideal for Parallel Tasks** â†’ You still need `Promise.all()` to run multiple async operations together.

---

âœ… **Summary Insight:**

* **Callbacks** â†’ simple but messy.
* **Promises** â†’ structured but still verbose.
* **Async functions** â†’ easier but still depend on Promises.
* **Async/Await** â†’ cleanest syntax but can slow down parallel tasks if used carelessly.

---

Would you like me to add a **real-world analogy** (like ordering food â†’ callback vs promise vs async/await) to make the differences feel intuitive?



* **Promise** â†’ part of **ECMAScript (JS language)**, introduced in **ES6 (2015)** for async handling.
* **`fetch()`** â†’ part of **browser Web APIs written in c++ in their browsers, not ECMAScript.
* Before `fetch()`, browsers used **`XMLHttpRequest` (XHR)** for network requests.
* `fetch()` is in chrome uses **Promise** under the hood to return async results.
----------------------------------------
