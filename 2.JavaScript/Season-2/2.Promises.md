Here’s a clean, **well-structured set of notes** for your **Episode 21: Promises** — with clear sections, code highlights, and interview takeaways 👇

---

# ⚡ Episode 21: Promises

> **Promises** are used to handle **asynchronous operations** in JavaScript.

---

## 🔹 Before Promises — Using Callbacks

```js
const cart = ["shoes", "pants", "kurta"];

// Async functions dependent on each other
const orderId = createOrder(cart);
proceedToPayment(orderId);

// Using callback (old way)
createOrder(cart, function () {
  proceedToPayment(orderId);
});
```

### ❌ Problem: *Inversion of Control*

* We **pass** a callback into another function.
* We must **trust** it to call the callback correctly.
* Hard to maintain, especially when there are multiple async calls.

---

## 🔹 After Promises — Using `.then()`

A **Promise**:

* Is like an **empty container (object)** that will **eventually** hold a value (e.g. `orderId`).
* Initially returns immediately with **`undefined`** data.
* When the async task finishes, it **fills** that value automatically.
* We can **attach a callback** using `.then()` that runs when the data is ready.

```js
const cart = ["shoes", "pants", "kurta"];

const promiseRef = createOrder(cart);

promiseRef.then(function (orderId) {
  proceedToPayment(orderId);
});
```

### ✅ Benefit

* We **attach** the callback instead of **passing** it.
* **Guarantee:**

  * `.then()` runs **only once** when data is ready.
  * No loss of control — the Promise ensures proper sequencing.

---

## 🔹 Real Promise Example — `fetch()`

```js
const URL = "https://api.github.com/users/alok722";
const user = fetch(URL);

console.log(user); // Promise {<Pending>}
```

### 🧠 What’s inside a Promise?

* `[[PromiseState]]`: `pending`, `fulfilled`, or `rejected`
* `[[PromiseResult]]`: stores the eventual data (initially `undefined`)

> When `fetch()` is called, it **returns a pending Promise** immediately.
> JS continues execution without waiting for completion.

---

### Attaching a Callback

```js
const URL = "https://api.github.com/users/alok722";
fetch(URL).then(function (data) {
  console.log(data);
});
```

### ⚙️ Promise States

| State       | Meaning              |
| ----------- | -------------------- |
| `pending`   | Initial state        |
| `fulfilled` | Operation successful |
| `rejected`  | Operation failed     |

---

### 💡 Key Points

* **Promises are immutable** → Once fulfilled, data cannot be changed.
* Use `.then()` to handle result instead of mutating Promise object.

---

## 🎯 Interview Essentials

**Q. What is a Promise?**

✅ *A Promise is an object representing the eventual completion or failure of an asynchronous operation.*

Other definitions:

* A **placeholder** for a future value.
* A **container** for the result of an async task.
* Helps handle async flow in a **clean and predictable** way.

---

## 🔹 Callback Hell

When callbacks are **nested within callbacks**, it creates a **pyramid of doom**:

```js
createOrder(cart, function (orderId) {
  proceedToPayment(orderId, function (paymentInf) {
    showOrderSummary(paymentInf, function (balance) {
      updateWalletBalance(balance);
    });
  });
});
```

### ❌ Issues:

* Hard to read and debug.
* Difficult to manage dependencies.

---

## 🔹 Solution — Promise Chaining

```js
createOrder(cart)
  .then(function (orderId) {
    return proceedToPayment(orderId);
  })
  .then(function (paymentInf) {
    return showOrderSummary(paymentInf);
  })
  .then(function (balance) {
    return updateWalletBalance(balance);
  });
```

### 💡 Promise Chaining Rules

* Always **return** the Promise in each `.then()` block.
* The **returned value** from one `.then()` becomes the **input** for the next.

✅ You can improve readability with **arrow functions**:

```js
createOrder(cart)
  .then(orderId => proceedToPayment(orderId))
  .then(paymentInf => showOrderSummary(paymentInf))
  .then(balance => updateWalletBalance(balance));
```

---

## 🧩 Summary

| Concept                  | Description                                          |
| ------------------------ | ---------------------------------------------------- |
| **Inversion of Control** | Callback decides when to execute next function       |
| **Promise**              | Placeholder for future value                         |
| **Promise States**       | Pending → Fulfilled / Rejected                       |
| **`.then()`**            | Attaches a callback to run when Promise is fulfilled |
| **Immutability**         | Promise result cannot be changed                     |
| **Promise Chaining**     | Handles multiple async steps in sequence             |

---

🎥 **Watch full episode:**
👉 [Akshay Saini – Promises in JavaScript (YouTube)](https://www.youtube.com/watch?v=ap-6PPAuK1Y&list=PLlasXeu85E9eWOpw9jxHOQyGMRiBZ60aX&index=3)

---

Would you like me to make a **visual summary chart** (flow diagram of how Promise state transitions work from `pending → fulfilled/rejected`)? It’s great for quick revision.
