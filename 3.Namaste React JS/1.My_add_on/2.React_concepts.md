# React v18+ Glossary - Enhanced Reference Guide

---

# ‚öõÔ∏è **CORE CONCEPTS**

---

### **Component**

| **Definition**  | Reusable piece of UI that returns JSX. Building block of React apps.                    |
| --------------- | ---------------------------------------------------------------------------------------- |
| **When to Use** | Always. Everything in React is a component.                                              |
| **Remarks**     | Prefer function components. Class components are legacy. Component names must be PascalCase. |

```jsx
// Function Component (Modern)
function Greeting({ name }) {
  return <h1>Hello, {name}!</h1>;
}

// Arrow Function Component
const Button = ({ onClick, children }) => (
  <button onClick={onClick}>{children}</button>
);

// Class Component (Legacy)
class Welcome extends React.Component {
  render() {
    return <h1>Hello, {this.props.name}</h1>;
  }
}
```

---

### **JSX**

| **Definition**  | JavaScript XML - syntax extension that looks like HTML but compiles to JavaScript.       |
| --------------- | ---------------------------------------------------------------------------------------- |
| **When to Use** | For defining component UI structure.                                                     |
| **Remarks**     | Must return single parent element. Use `className` not `class`. `{}` for JS expressions. |

```jsx
// Basic JSX
const element = <h1>Hello World</h1>;

// With expressions
const name = "Alice";
const element = <h1>Hello, {name}!</h1>;

// With attributes
const img = <img src={url} alt="Description" className="rounded" />;

// Multiple elements need wrapper
const layout = (
  <div>
    <h1>Title</h1>
    <p>Content</p>
  </div>
);

// Fragment for no wrapper
const list = (
  <>
    <li>Item 1</li>
    <li>Item 2</li>
  </>
);
```

---

### **Props**

| **Definition**  | Read-only data passed from parent to child component.                                    |
| --------------- | ---------------------------------------------------------------------------------------- |
| **When to Use** | Passing data down the component tree.                                                    |
| **Remarks**     | Immutable. Use destructuring for cleaner code. Can pass any type including functions.    |

```jsx
// Receiving props
function UserCard({ name, age, email }) {
  return (
    <div>
      <h2>{name}</h2>
      <p>Age: {age}</p>
      <p>Email: {email}</p>
    </div>
  );
}

// Passing props
<UserCard name="Alice" age={30} email="alice@example.com" />

// Default props
function Button({ text = "Click me", variant = "primary" }) {
  return <button className={variant}>{text}</button>;
}

// Children prop
function Card({ children }) {
  return <div className="card">{children}</div>;
}

<Card>
  <h1>Title</h1>
  <p>Content</p>
</Card>
```

---

### **State**

| **Definition**  | Mutable data managed within a component that causes re-renders when changed.             |
| --------------- | ---------------------------------------------------------------------------------------- |
| **When to Use** | For data that changes over time (form inputs, toggles, counters, etc).                  |
| **Remarks**     | Use `useState` hook. Updates are asynchronous. Never mutate state directly.              |

```jsx
import { useState } from 'react';

function Counter() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>
        Increment
      </button>
    </div>
  );
}

// With object state
function Form() {
  const [user, setUser] = useState({ name: '', email: '' });

  const updateName = (name) => {
    setUser(prev => ({ ...prev, name }));
  };

  return <input value={user.name} onChange={e => updateName(e.target.value)} />;
}
```

---

### **Virtual DOM**

| **Definition**  | React's in-memory representation of the actual DOM for efficient updates.                |
| --------------- | ---------------------------------------------------------------------------------------- |
| **When to Use** | Automatically handled by React.                                                          |
| **Remarks**     | React compares (diffing) and updates only changed parts. Makes React fast.               |

```jsx
// React handles this automatically
// When state changes, React:
// 1. Creates new virtual DOM
// 2. Diffs with previous virtual DOM
// 3. Updates only changed real DOM nodes

function App() {
  const [count, setCount] = useState(0);
  
  // Only the <p> updates in DOM, not entire component
  return (
    <div>
      <h1>My App</h1>
      <p>{count}</p>
      <button onClick={() => setCount(count + 1)}>Update</button>
    </div>
  );
}
```

---

### **Reconciliation**

| **Definition**  | Process of comparing virtual DOM trees to determine minimal DOM updates.                 |
| --------------- | ---------------------------------------------------------------------------------------- |
| **When to Use** | Automatic. Use `key` prop for list optimization.                                         |
| **Remarks**     | React's diffing algorithm. Keys help React identify which items changed.                 |

```jsx
// Without keys (bad - can cause bugs)
{items.map(item => <li>{item.name}</li>)}

// With keys (good)
{items.map(item => (
  <li key={item.id}>{item.name}</li>
))}

// Don't use index as key if list can reorder
{items.map((item, index) => (
  <li key={item.id}>{item.name}</li> // ‚úì Good
  // <li key={index}>{item.name}</li> // ‚úó Bad for dynamic lists
))}
```

---

# üé£ **HOOKS**

---

### **useState**

| **Definition**  | Hook to add state to function components.                                                |
| --------------- | ---------------------------------------------------------------------------------------- |
| **When to Use** | Managing component-level data that changes.                                              |
| **Remarks**     | Returns `[state, setter]`. Setter can take value or updater function. Triggers re-render.|

```jsx
import { useState } from 'react';

// Basic usage
const [count, setCount] = useState(0);

// With initial function (lazy initialization)
const [data, setData] = useState(() => {
  return expensiveComputation();
});

// Multiple states
function Form() {
  const [name, setName] = useState('');
  const [email, setEmail] = useState('');
  const [age, setAge] = useState(0);
}

// Functional updates (when new state depends on previous)
setCount(prevCount => prevCount + 1);

// Object state
const [user, setUser] = useState({ name: '', email: '' });
setUser(prev => ({ ...prev, name: 'Alice' }));
```

---

### **useEffect**

| **Definition**  | Hook for side effects (data fetching, subscriptions, manual DOM changes).                |
| --------------- | ---------------------------------------------------------------------------------------- |
| **When to Use** | After render operations, API calls, event listeners, timers.                             |
| **Remarks**     | Runs after render. Dependency array controls when it runs. Return cleanup function.      |

```jsx
import { useEffect } from 'react';

// Runs after every render
useEffect(() => {
  console.log('Component rendered');
});

// Runs once on mount (empty deps)
useEffect(() => {
  fetchData();
}, []);

// Runs when deps change
useEffect(() => {
  document.title = `Count: ${count}`;
}, [count]);

// With cleanup
useEffect(() => {
  const timer = setInterval(() => tick(), 1000);
  
  return () => clearInterval(timer); // Cleanup
}, []);

// Async in useEffect
useEffect(() => {
  async function loadData() {
    const response = await fetch('/api/data');
    const data = await response.json();
    setData(data);
  }
  loadData();
}, []);
```

---

### **useContext**

| **Definition**  | Hook to consume context values without prop drilling.                                    |
| --------------- | ---------------------------------------------------------------------------------------- |
| **When to Use** | Accessing global state (theme, auth, language) deep in component tree.                  |
| **Remarks**     | Component re-renders when context value changes. Use with `React.createContext()`.       |

```jsx
import { createContext, useContext, useState } from 'react';

// Create context
const ThemeContext = createContext();

// Provider component
function App() {
  const [theme, setTheme] = useState('light');
  
  return (
    <ThemeContext.Provider value={{ theme, setTheme }}>
      <Toolbar />
    </ThemeContext.Provider>
  );
}

// Consume context
function ThemedButton() {
  const { theme, setTheme } = useContext(ThemeContext);
  
  return (
    <button 
      className={theme}
      onClick={() => setTheme(theme === 'light' ? 'dark' : 'light')}
    >
      Toggle Theme
    </button>
  );
}
```

---

### **useReducer**

| **Definition**  | Hook for complex state logic with actions/reducer pattern.                               |
| --------------- | ---------------------------------------------------------------------------------------- |
| **When to Use** | Complex state updates, multiple related state values, state depends on previous state.  |
| **Remarks**     | Alternative to `useState`. Similar to Redux pattern. Better for complex state logic.     |

```jsx
import { useReducer } from 'react';

// Reducer function
function counterReducer(state, action) {
  switch (action.type) {
    case 'increment':
      return { count: state.count + 1 };
    case 'decrement':
      return { count: state.count - 1 };
    case 'reset':
      return { count: 0 };
    default:
      throw new Error(`Unknown action: ${action.type}`);
  }
}

function Counter() {
  const [state, dispatch] = useReducer(counterReducer, { count: 0 });
  
  return (
    <div>
      <p>Count: {state.count}</p>
      <button onClick={() => dispatch({ type: 'increment' })}>+</button>
      <button onClick={() => dispatch({ type: 'decrement' })}>-</button>
      <button onClick={() => dispatch({ type: 'reset' })}>Reset</button>
    </div>
  );
}
```

---

### **useRef**

| **Definition**  | Hook to persist values across renders without causing re-renders.                        |
| --------------- | ---------------------------------------------------------------------------------------- |
| **When to Use** | DOM access, storing mutable values, keeping previous values, timers.                     |
| **Remarks**     | Returns mutable object with `.current` property. Doesn't trigger re-renders when changed.|

```jsx
import { useRef, useEffect } from 'react';

// DOM reference
function TextInput() {
  const inputRef = useRef(null);
  
  useEffect(() => {
    inputRef.current.focus();
  }, []);
  
  return <input ref={inputRef} />;
}

// Storing mutable value
function Timer() {
  const intervalRef = useRef(null);
  
  const start = () => {
    intervalRef.current = setInterval(() => {
      console.log('tick');
    }, 1000);
  };
  
  const stop = () => {
    clearInterval(intervalRef.current);
  };
  
  return (
    <>
      <button onClick={start}>Start</button>
      <button onClick={stop}>Stop</button>
    </>
  );
}

// Previous value
function Counter() {
  const [count, setCount] = useState(0);
  const prevCount = useRef();
  
  useEffect(() => {
    prevCount.current = count;
  });
  
  return <p>Now: {count}, Before: {prevCount.current}</p>;
}
```

---

### **useMemo**

| **Definition**  | Hook to memoize expensive computations.                                                  |
| --------------- | ---------------------------------------------------------------------------------------- |
| **When to Use** | Expensive calculations, preventing unnecessary recalculations.                           |
| **Remarks**     | Returns memoized value. Recomputes only when dependencies change. Performance optimization.|

```jsx
import { useMemo } from 'react';

function ExpensiveComponent({ items, filter }) {
  // Only recalculates when items or filter change
  const filteredItems = useMemo(() => {
    console.log('Filtering...');
    return items.filter(item => item.includes(filter));
  }, [items, filter]);
  
  return (
    <ul>
      {filteredItems.map(item => (
        <li key={item}>{item}</li>
      ))}
    </ul>
  );
}

// Memoizing object to prevent reference changes
function Parent() {
  const [count, setCount] = useState(0);
  
  const config = useMemo(() => ({
    apiKey: 'abc123',
    timeout: 5000
  }), []); // Only created once
  
  return <Child config={config} />;
}
```

---

### **useCallback**

| **Definition**  | Hook to memoize function references.                                                     |
| --------------- | ---------------------------------------------------------------------------------------- |
| **When to Use** | Passing callbacks to optimized child components, preventing unnecessary re-renders.     |
| **Remarks**     | Returns memoized callback. Useful with `React.memo()`. Prevents function recreation.    |

```jsx
import { useCallback, memo } from 'react';

function Parent() {
  const [count, setCount] = useState(0);
  
  // Function recreated on every render (bad for Child)
  const handleClick = () => {
    console.log('clicked');
  };
  
  // Function memoized (good for Child)
  const handleClickMemo = useCallback(() => {
    console.log('clicked');
  }, []);
  
  return <Child onClick={handleClickMemo} />;
}

// Memoized child only re-renders if props change
const Child = memo(({ onClick }) => {
  console.log('Child rendered');
  return <button onClick={onClick}>Click</button>;
});

// With dependencies
function SearchComponent() {
  const [query, setQuery] = useState('');
  
  const search = useCallback(async () => {
    const results = await fetch(`/api/search?q=${query}`);
    return results.json();
  }, [query]); // Recreated when query changes
  
  return <SearchResults onSearch={search} />;
}
```

---

### **useLayoutEffect**

| **Definition**  | Like useEffect but fires synchronously after DOM mutations, before paint.                |
| --------------- | ---------------------------------------------------------------------------------------- |
| **When to Use** | Reading DOM layout, synchronous DOM updates, preventing flicker.                         |
| **Remarks**     | Blocks visual updates. Use sparingly. Most cases should use `useEffect` instead.         |

```jsx
import { useLayoutEffect, useRef } from 'react';

function TooltipComponent() {
  const tooltipRef = useRef();
  
  useLayoutEffect(() => {
    // Measure and position tooltip before paint
    const { height } = tooltipRef.current.getBoundingClientRect();
    tooltipRef.current.style.marginTop = `-${height}px`;
  }, []);
  
  return <div ref={tooltipRef}>Tooltip</div>;
}

// Measuring DOM before user sees it
function Measureable() {
  const [height, setHeight] = useState(0);
  const ref = useRef();
  
  useLayoutEffect(() => {
    setHeight(ref.current.getBoundingClientRect().height);
  }, []);
  
  return <div ref={ref}>Height: {height}</div>;
}
```

---

### **useImperativeHandle**

| **Definition**  | Customizes the instance value exposed to parent via ref.                                 |
| --------------- | ---------------------------------------------------------------------------------------- |
| **When to Use** | Creating reusable components with custom imperative methods.                             |
| **Remarks**     | Use with `forwardRef`. Avoid overuse - prefer declarative patterns when possible.        |

```jsx
import { useImperativeHandle, forwardRef, useRef } from 'react';

const CustomInput = forwardRef((props, ref) => {
  const inputRef = useRef();
  
  useImperativeHandle(ref, () => ({
    focus: () => {
      inputRef.current.focus();
    },
    clear: () => {
      inputRef.current.value = '';
    },
    getValue: () => {
      return inputRef.current.value;
    }
  }));
  
  return <input ref={inputRef} {...props} />;
});

// Parent component
function Form() {
  const inputRef = useRef();
  
  const handleSubmit = () => {
    const value = inputRef.current.getValue();
    inputRef.current.clear();
  };
  
  return (
    <>
      <CustomInput ref={inputRef} />
      <button onClick={handleSubmit}>Submit</button>
    </>
  );
}
```

---

### **useDebugValue**

| **Definition**  | Displays custom label in React DevTools for custom hooks.                                |
| --------------- | ---------------------------------------------------------------------------------------- |
| **When to Use** | Debugging custom hooks, adding meaningful labels in DevTools.                            |
| **Remarks**     | Only for development. No runtime cost in production. Use in custom hooks only.           |

```jsx
import { useDebugValue, useState, useEffect } from 'react';

function useOnlineStatus() {
  const [isOnline, setIsOnline] = useState(navigator.onLine);
  
  useEffect(() => {
    const handler = () => setIsOnline(navigator.onLine);
    window.addEventListener('online', handler);
    window.addEventListener('offline', handler);
    return () => {
      window.removeEventListener('online', handler);
      window.removeEventListener('offline', handler);
    };
  }, []);
  
  // Shows in DevTools
  useDebugValue(isOnline ? 'Online' : 'Offline');
  
  return isOnline;
}

// With formatter function (only computed when DevTools open)
function useCustomHook(value) {
  useDebugValue(value, v => `Custom: ${v.toUpperCase()}`);
  return value;
}
```

---

# üÜï **REACT 18 NEW HOOKS**

---

### **useId**

| **Definition**  | Generates unique IDs for accessibility attributes.                                       |
| --------------- | ---------------------------------------------------------------------------------------- |
| **When to Use** | Form labels, ARIA attributes, linking elements.                                          |
| **Remarks**     | SSR-safe. Generates same ID on server and client. Unique per component instance.         |

```jsx
import { useId } from 'react';

function TextField({ label }) {
  const id = useId();
  
  return (
    <div>
      <label htmlFor={id}>{label}</label>
      <input id={id} type="text" />
    </div>
  );
}

// Multiple IDs in same component
function PasswordField() {
  const passwordHintId = useId();
  
  return (
    <>
      <input
        type="password"
        aria-describedby={passwordHintId}
      />
      <p id={passwordHintId}>
        Password must be at least 8 characters
      </p>
    </>
  );
}
```

---

### **useTransition**

| **Definition**  | Marks state updates as non-urgent transitions.                                           |
| --------------- | ---------------------------------------------------------------------------------------- |
| **When to Use** | Keeping UI responsive during slow updates (searches, filtering large lists).            |
| **Remarks**     | Returns `[isPending, startTransition]`. Transitions can be interrupted by urgent updates.|

```jsx
import { useState, useTransition } from 'react';

function SearchResults() {
  const [query, setQuery] = useState('');
  const [results, setResults] = useState([]);
  const [isPending, startTransition] = useTransition();
  
  const handleChange = (e) => {
    // Urgent: update input immediately
    setQuery(e.target.value);
    
    // Non-urgent: filter can be delayed
    startTransition(() => {
      const filtered = items.filter(item =>
        item.toLowerCase().includes(e.target.value.toLowerCase())
      );
      setResults(filtered);
    });
  };
  
  return (
    <div>
      <input value={query} onChange={handleChange} />
      {isPending && <Spinner />}
      <ul>{results.map(r => <li key={r}>{r}</li>)}</ul>
    </div>
  );
}
```

---

### **useDeferredValue**

| **Definition**  | Defers updating a value until more urgent updates finish.                                |
| --------------- | ---------------------------------------------------------------------------------------- |
| **When to Use** | Deferring expensive renders while keeping UI responsive.                                 |
| **Remarks**     | Alternative to `useTransition`. Good when you can't wrap the update in startTransition. |

```jsx
import { useState, useDeferredValue, memo } from 'react';

function App() {
  const [text, setText] = useState('');
  const deferredText = useDeferredValue(text);
  
  return (
    <div>
      <input value={text} onChange={e => setText(e.target.value)} />
      <ExpensiveList query={deferredText} />
    </div>
  );
}

// Renders with deferred value, won't block input
const ExpensiveList = memo(({ query }) => {
  const items = useMemo(() => {
    // Expensive filtering
    return bigList.filter(item => item.includes(query));
  }, [query]);
  
  return <ul>{items.map(i => <li key={i}>{i}</li>)}</ul>;
});
```

---

### **useSyncExternalStore**

| **Definition**  | Subscribe to external stores (non-React state).                                          |
| --------------- | ---------------------------------------------------------------------------------------- |
| **When to Use** | Integrating with external state management, browser APIs, global stores.                |
| **Remarks**     | Ensures consistent reads during concurrent rendering. Use for external subscriptions.    |

```jsx
import { useSyncExternalStore } from 'react';

// External store
const store = {
  listeners: new Set(),
  state: { count: 0 },
  
  subscribe(listener) {
    this.listeners.add(listener);
    return () => this.listeners.delete(listener);
  },
  
  getSnapshot() {
    return this.state;
  },
  
  increment() {
    this.state = { count: this.state.count + 1 };
    this.listeners.forEach(l => l());
  }
};

function Counter() {
  const state = useSyncExternalStore(
    store.subscribe.bind(store),
    store.getSnapshot.bind(store)
  );
  
  return (
    <div>
      <p>Count: {state.count}</p>
      <button onClick={() => store.increment()}>+</button>
    </div>
  );
}

// Browser API example
function useOnlineStatus() {
  return useSyncExternalStore(
    (callback) => {
      window.addEventListener('online', callback);
      window.addEventListener('offline', callback);
      return () => {
        window.removeEventListener('online', callback);
        window.removeEventListener('offline', callback);
      };
    },
    () => navigator.onLine
  );
}
```

---

### **useInsertionEffect**

| **Definition**  | Fires before DOM mutations, designed for CSS-in-JS libraries.                            |
| --------------- | ---------------------------------------------------------------------------------------- |
| **When to Use** | CSS-in-JS library authors only. Injecting styles before layout.                          |
| **Remarks**     | Not for app developers. Use `useLayoutEffect` or `useEffect` instead. Very specialized. |

```jsx
import { useInsertionEffect } from 'react';

// CSS-in-JS library usage (not typical app code)
function useCSS(rule) {
  useInsertionEffect(() => {
    // Inject style before browser calculates layout
    const style = document.createElement('style');
    style.textContent = rule;
    document.head.appendChild(style);
    
    return () => {
      document.head.removeChild(style);
    };
  }, [rule]);
}

function Component() {
  useCSS('.my-class { color: red; }');
  return <div className="my-class">Styled</div>;
}
```

---

# üìã **COMPONENT PATTERNS**

---

### **Controlled Components**

| **Definition**  | Form elements whose value is controlled by React state.                                  |
| --------------- | ---------------------------------------------------------------------------------------- |
| **When to Use** | Forms where React needs to control/validate input values.                                |
| **Remarks**     | Single source of truth. Value always matches state. Enables validation and formatting.   |

```jsx
function ControlledInput() {
  const [value, setValue] = useState('');
  
  return (
    <input
      value={value}
      onChange={e => setValue(e.target.value)}
    />
  );
}

// Form example
function LoginForm() {
  const [form, setForm] = useState({ email: '', password: '' });
  
  const handleSubmit = (e) => {
    e.preventDefault();
    console.log(form);
  };
  
  const handleChange = (e) => {
    setForm(prev => ({
      ...prev,
      [e.target.name]: e.target.value
    }));
  };
  
  return (
    <form onSubmit={handleSubmit}>
      <input
        name="email"
        value={form.email}
        onChange={handleChange}
      />
      <input
        name="password"
        type="password"
        value={form.password}
        onChange={handleChange}
      />
      <button type="submit">Login</button>
    </form>
  );
}
```

---

### **Uncontrolled Components**

| **Definition**  | Form elements that maintain their own state in DOM.                                      |
| --------------- | ---------------------------------------------------------------------------------------- |
| **When to Use** | Simple forms, file inputs, integrating with non-React code.                              |
| **Remarks**     | Use refs to access values. Less React-like. Good for quick prototypes or simple forms.  |

```jsx
function UncontrolledInput() {
  const inputRef = useRef();
  
  const handleSubmit = () => {
    console.log(inputRef.current.value);
  };
  
  return (
    <>
      <input ref={inputRef} defaultValue="Initial" />
      <button onClick={handleSubmit}>Submit</button>
    </>
  );
}

// File input (always uncontrolled)
function FileUpload() {
  const fileRef = useRef();
  
  const handleUpload = () => {
    const file = fileRef.current.files[0];
    console.log(file);
  };
  
  return (
    <>
      <input type="file" ref={fileRef} />
      <button onClick={handleUpload}>Upload</button>
    </>
  );
}
```

---

### **Higher-Order Components (HOC)**

| **Definition**  | Function that takes a component and returns enhanced component.                          |
| --------------- | ---------------------------------------------------------------------------------------- |
| **When to Use** | Code reuse, cross-cutting concerns (auth, logging, analytics).                          |
| **Remarks**     | Legacy pattern. Prefer hooks in modern React. Useful for libraries or legacy code.      |

```jsx
// HOC definition
function withAuth(Component) {
  return function AuthenticatedComponent(props) {
    const { user } = useAuth();
    
    if (!user) {
      return <Login />;
    }
    
    return <Component {...props} user={user} />;
  };
}

// Usage
const Dashboard = ({ user }) => {
  return <h1>Welcome, {user.name}</h1>;
};

const ProtectedDashboard = withAuth(Dashboard);

// Multiple HOCs
const EnhancedComponent = withAuth(withLogging(withAnalytics(MyComponent)));
```

---

### **Render Props**

| **Definition**  | Pattern where component receives function as children/prop to share logic.               |
| --------------- | ---------------------------------------------------------------------------------------- |
| **When to Use** | Sharing stateful logic, flexible component composition.                                  |
| **Remarks**     | Legacy pattern. Hooks are now preferred. Still seen in some libraries.                   |

```jsx
// Render prop pattern
function MouseTracker({ render }) {
  const [position, setPosition] = useState({ x: 0, y: 0 });
  
  useEffect(() => {
    const handler = (e) => {
      setPosition({ x: e.clientX, y: e.clientY });
    };
    
    window.addEventListener('mousemove', handler);
    return () => window.removeEventListener('mousemove', handler);
  }, []);
  
  return render(position);
}

// Usage
function App() {
  return (
    <MouseTracker
      render={({ x, y }) => (
        <h1>Mouse at {x}, {y}</h1>
      )}
    />
  );
}

// Children as function
function Toggle({ children }) {
  const [on, setOn] = useState(false);
  
  return children({
    on,
    toggle: () => setOn(!on)
  });
}

<Toggle>
  {({ on, toggle }) => (
    <button onClick={toggle}>
      {on ? 'ON' : 'OFF'}
    </button>
  )}
</Toggle>
```

---

### **Compound Components**

| **Definition**  | Components that work together sharing implicit state.                                    |
| --------------- | ---------------------------------------------------------------------------------------- |
| **When to Use** | Building flexible, composable UI kits (tabs, accordions, menus).                        |
| **Remarks**     | Uses Context API. Provides flexibility while maintaining simplicity. Great for libraries.|

```jsx
const TabsContext = createContext();

function Tabs({ children }) {
  const [activeTab, setActiveTab] = useState(0);
  
  return (
    <TabsContext.Provider value={{ activeTab, setActiveTab }}>
      <div className="tabs">{children}</div>
    </TabsContext.Provider>
  );
}

function TabList({ children }) {
  return <div className="tab-list">{children}</div>;
}

function Tab({ index, children }) {
  const { activeTab, setActiveTab } = useContext(TabsContext);
  
  return (
    <button
      className={activeTab === index ? 'active' : ''}
      onClick={() => setActiveTab(index)}
    >
      {children}
    </button>
  );
}

function TabPanel({ index, children }) {
  const { activeTab } = useContext(TabsContext);
  
  return activeTab === index ? <div>{children}</div> : null;
}

// Usage
<Tabs>
  <TabList>
    <Tab index={0}>Tab 1</Tab>
    <Tab index={1}>Tab 2</Tab>
  </TabList>
  <TabPanel index={0}>Content 1</TabPanel>
  <TabPanel index={1}>Content 2</TabPanel>
</Tabs>
```

---

### **Custom Hooks**

| **Definition**  | Reusable functions that use React hooks to share stateful logic.                         |
| --------------- | ---------------------------------------------------------------------------------------- |
| **When to Use** | Extracting component logic, sharing behavior across components.                          |
| **Remarks**     | Must start with "use". Can use other hooks. Preferred over HOCs and render props.        |

```jsx
// Custom hook for form handling
function useForm(initialValues) {
  const [values, setValues] = useState(initialValues);
  
  const handleChange = (e) => {
    setValues(prev => ({
      ...prev,
      [e.target.name]: e.target.value
    }));
  };
  
  const reset = () => setValues(initialValues);
  
  return { values, handleChange, reset };
}

// Usage
function LoginForm() {
  const { values, handleChange, reset } = useForm({
    email: '',
    password: ''
  });
  
  return (
    <form>
      <input name="email" value={values.email} onChange={handleChange} />
      <input name="password" value={values.password} onChange={handleChange} />
      <button onClick={reset}>Reset</button>
    </form>
  );
}

// Custom hook for API fetching
function useFetch(url) {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  
  useEffect(() => {
    async function fetchData() {
      try {
        const response = await fetch(url);
        const json = await response.json();
        setData(json);
      } catch (err) {
        setError(err);
      } finally {
        setLoading(false);
      }
    }
    
    fetchData();
  }, [url]);
  
  return { data, loading, error };
}

// Usage
function UserProfile({ userId }) {
  const { data, loading, error } = useFetch(`/api/users/${userId}`);
  
  if (loading) return <Spinner />;
  if (error) return <Error message={error.message} />;
  return <div>{data.name}</div>;
}
```

---

# üé® **STYLING APPROACHES**

---

### **Inline Styles**

| **Definition**  | Styles defined as JavaScript objects in style prop.                                      |
| --------------- | ---------------------------------------------------------------------------------------- |
| **When to Use** | Dynamic styles, prototypes, simple component-specific styles.                            |
| **Remarks**     | camelCase properties. Limited (no pseudo-classes, media queries). Inline specificity.    |

```jsx
function Button({ variant, size }) {
  const styles = {
    padding: size === 'large' ? '12px 24px' : '8px 16px',
    backgroundColor: variant === 'primary' ? '#007bff' : '#6c757d',
    color: 'white',
    border: 'none',
    borderRadius: '4px',
    cursor: 'pointer',
    fontSize: size === 'large' ? '18px' : '14px'
  };
  
  return <button style={styles}>Click me</button>;
}

// Dynamic styles
function ProgressBar({ progress }) {
  return (
    <div style={{ 
      width: '100%', 
      backgroundColor: '#eee',
      borderRadius: '4px'
    }}>
      <div style={{
        width: `${progress}%`,
        height: '20px',
        backgroundColor: '#4caf50',
        transition: 'width 0.3s ease'
      }} />
    </div>
  );
}
```

---

### **CSS Modules**

| **Definition**  | CSS files where class names are locally scoped by default.                               |
| --------------- | ---------------------------------------------------------------------------------------- |
| **When to Use** | Component-scoped styles, avoiding global conflicts, larger apps.                         |
| **Remarks**     | Requires build setup. Auto-generates unique class names. Great for maintainability.      |

```css
/* Button.module.css */
.button {
  padding: 8px 16px;
  border-radius: 4px;
  border: none;
  cursor: pointer;
}

.primary {
  background-color: #007bff;
  color: white;
}

.secondary {
  background-color: #6c757d;
  color: white;
}
```

```jsx
// Button.jsx
import styles from './Button.module.css';

function Button({ variant = 'primary', children }) {
  return (
    <button className={`${styles.button} ${styles[variant]}`}>
      {children}
    </button>
  );
}

// Generated HTML: <button class="Button_button__x7k9 Button_primary__a3b2">
```

---

### **Styled Components**

| **Definition**  | CSS-in-JS library using tagged template literals.                                        |
| --------------- | ---------------------------------------------------------------------------------------- |
| **When to Use** | Dynamic styling based on props, theming, component libraries.                            |
| **Remarks**     | Generates unique class names. Supports full CSS. Popular in React ecosystem.             |

```jsx
import styled from 'styled-components';

// Basic styled component
const Button = styled.button`
  padding: 8px 16px;
  border-radius: 4px;
  border: none;
  cursor: pointer;
  background-color: ${props => props.primary ? '#007bff' : '#6c757d'};
  color: white;
  font-size: ${props => props.size === 'large' ? '18px' : '14px'};
  
  &:hover {
    opacity: 0.9;
  }
  
  &:disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }
`;

// Usage
<Button primary size="large">Click me</Button>

// Extending styles
const RedButton = styled(Button)`
  background-color: #dc3545;
`;

// With theme
const ThemedButton = styled.button`
  background-color: ${props => props.theme.primaryColor};
  color: ${props => props.theme.textColor};
`;
```

---

### **Tailwind CSS**

| **Definition**  | Utility-first CSS framework with pre-defined classes.                                    |
| --------------- | ---------------------------------------------------------------------------------------- |
| **When to Use** | Rapid development, consistent design systems, utility-first approach.                    |
| **Remarks**     | No custom CSS needed. Highly customizable. Popular for modern React apps.                |

```jsx
function Card({ title, content, featured }) {
  return (
    <div className={`
      rounded-lg 
      shadow-md 
      p-6 
      ${featured ? 'bg-blue-500 text-white' : 'bg-white'}
      hover:shadow-lg 
      transition-shadow
    `}>
      <h2 className="text-2xl font-bold mb-4">{title}</h2>
      <p className="text-gray-600">{content}</p>
    </div>
  );
}

// Responsive design
function ResponsiveLayout() {
  return (
    <div className="
      grid 
      grid-cols-1 
      md:grid-cols-2 
      lg:grid-cols-3 
      gap-4
    ">
      {items.map(item => <Card key={item.id} {...item} />)}
    </div>
  );
}

// With conditional classes (using clsx or classnames)
import clsx from 'clsx';

function Button({ variant, size, disabled }) {
  return (
    <button className={clsx(
      'rounded font-semibold transition-colors',
      {
        'bg-blue-500 hover:bg-blue-600 text-white': variant === 'primary',
        'bg-gray-200 hover:bg-gray-300 text-gray-800': variant === 'secondary',
        'px-6 py-3 text-lg': size === 'large',
        'px-4 py-2 text-base': size === 'medium',
        'opacity-50 cursor-not-allowed': disabled
      }
    )}>
      Click me
    </button>
  );
}
```

---

# ‚ö° **PERFORMANCE OPTIMIZATION**

---

### **React.memo**

| **Definition**  | Higher-order component that memoizes functional components.                              |
| --------------- | ---------------------------------------------------------------------------------------- |
| **When to Use** | Expensive components that re-render often with same props.                               |
| **Remarks**     | Shallow props comparison. Custom comparison function optional. Use judiciously.          |

```jsx
import { memo } from 'react';

// Without memo - re-renders every time parent renders
function ExpensiveComponent({ data }) {
  console.log('Rendering...');
  return <div>{/* expensive render */}</div>;
}

// With memo - only re-renders when props change
const MemoizedComponent = memo(ExpensiveComponent);

// Custom comparison
const MemoizedWithComparison = memo(
  ExpensiveComponent,
  (prevProps, nextProps) => {
    // Return true if props are equal (skip render)
    return prevProps.data.id === nextProps.data.id;
  }
);

// Real-world example
const ListItem = memo(({ item, onEdit, onDelete }) => {
  return (
    <div>
      <span>{item.name}</span>
      <button onClick={() => onEdit(item.id)}>Edit</button>
      <button onClick={() => onDelete(item.id)}>Delete</button>
    </div>
  );
});
```

---

### **Code Splitting**

| **Definition**  | Splitting code into smaller bundles loaded on demand.                                    |
| --------------- | ---------------------------------------------------------------------------------------- |
| **When to Use** | Large apps, route-based splitting, heavy components.                                     |
| **Remarks**     | Uses `React.lazy()` and `Suspense`. Reduces initial bundle size. Improves load time.    |

```jsx
import { lazy, Suspense } from 'react';

// Lazy load component
const HeavyComponent = lazy(() => import('./HeavyComponent'));
const Dashboard = lazy(() => import('./pages/Dashboard'));
const Profile = lazy(() => import('./pages/Profile'));

function App() {
  return (
    <Suspense fallback={<LoadingSpinner />}>
      <HeavyComponent />
    </Suspense>
  );
}

// Route-based code splitting
import { BrowserRouter, Routes, Route } from 'react-router-dom';

function AppRoutes() {
  return (
    <BrowserRouter>
      <Suspense fallback={<PageLoader />}>
        <Routes>
          <Route path="/" element={<Home />} />
          <Route path="/dashboard" element={<Dashboard />} />
          <Route path="/profile" element={<Profile />} />
        </Routes>
      </Suspense>
    </BrowserRouter>
  );
}

// Named exports
const { ModuleA, ModuleB } = lazy(() =>
  import('./modules').then(module => ({
    default: {
      ModuleA: module.ModuleA,
      ModuleB: module.ModuleB
    }
  }))
);
```

---

### **Virtualization**

| **Definition**  | Rendering only visible items in large lists for performance.                             |
| --------------- | ---------------------------------------------------------------------------------------- |
| **When to Use** | Long lists (1000+ items), tables, infinite scroll.                                       |
| **Remarks**     | Use libraries like `react-window` or `react-virtualized`. Massive performance boost.     |

```jsx
import { FixedSizeList } from 'react-window';

// Without virtualization (slow for 10,000 items)
function SlowList({ items }) {
  return (
    <div>
      {items.map(item => (
        <div key={item.id}>{item.name}</div>
      ))}
    </div>
  );
}

// With virtualization (fast for any number)
function VirtualizedList({ items }) {
  const Row = ({ index, style }) => (
    <div style={style}>
      {items[index].name}
    </div>
  );
  
  return (
    <FixedSizeList
      height={600}
      itemCount={items.length}
      itemSize={50}
      width="100%"
    >
      {Row}
    </FixedSizeList>
  );
}

// Variable size list
import { VariableSizeList } from 'react-window';

function VariableList({ items }) {
  const getItemSize = (index) => {
    return items[index].content.length > 100 ? 100 : 50;
  };
  
  return (
    <VariableSizeList
      height={600}
      itemCount={items.length}
      itemSize={getItemSize}
      width="100%"
    >
      {Row}
    </VariableSizeList>
  );
}
```

---

### **Debouncing & Throttling**

| **Definition**  | Limiting how often functions execute to improve performance.                             |
| --------------- | ---------------------------------------------------------------------------------------- |
| **When to Use** | Search inputs, scroll handlers, resize events, API calls.                                |
| **Remarks**     | Debounce waits for pause. Throttle limits frequency. Use lodash or custom hooks.        |

```jsx
import { useState, useEffect } from 'react';
import { debounce } from 'lodash';

// Debounced search
function SearchBar() {
  const [query, setQuery] = useState('');
  const [results, setResults] = useState([]);
  
  useEffect(() => {
    const debouncedSearch = debounce(async (searchTerm) => {
      if (searchTerm) {
        const data = await fetch(`/api/search?q=${searchTerm}`);
        setResults(await data.json());
      }
    }, 300);
    
    debouncedSearch(query);
    
    return () => debouncedSearch.cancel();
  }, [query]);
  
  return (
    <input
      value={query}
      onChange={(e) => setQuery(e.target.value)}
      placeholder="Search..."
    />
  );
}

// Custom debounce hook
function useDebounce(value, delay) {
  const [debouncedValue, setDebouncedValue] = useState(value);
  
  useEffect(() => {
    const handler = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);
    
    return () => clearTimeout(handler);
  }, [value, delay]);
  
  return debouncedValue;
}

// Usage
function SearchWithHook() {
  const [query, setQuery] = useState('');
  const debouncedQuery = useDebounce(query, 500);
  
  useEffect(() => {
    if (debouncedQuery) {
      searchAPI(debouncedQuery);
    }
  }, [debouncedQuery]);
  
  return <input value={query} onChange={e => setQuery(e.target.value)} />;
}
```

---

### **Key Optimization**

| **Definition**  | Using stable, unique keys for list items to optimize reconciliation.                     |
| --------------- | ---------------------------------------------------------------------------------------- |
| **When to Use** | Rendering lists, dynamic collections.                                                    |
| **Remarks**     | Never use index as key for dynamic lists. Use unique IDs. Critical for performance.     |

```jsx
// Bad - using index (causes bugs on reorder/filter)
{items.map((item, index) => (
  <div key={index}>{item.name}</div>
))}

// Good - using unique ID
{items.map(item => (
  <div key={item.id}>{item.name}</div>
))}

// Bad - no key
{items.map(item => (
  <div>{item.name}</div>
))}

// Good - composite key when no unique ID
{items.map((item, index) => (
  <div key={`${item.category}-${index}`}>{item.name}</div>
))}

// Real-world example with filter
function TodoList() {
  const [filter, setFilter] = useState('all');
  const [todos, setTodos] = useState([
    { id: 1, text: 'Learn React', completed: false },
    { id: 2, text: 'Build app', completed: false }
  ]);
  
  const filtered = todos.filter(todo => {
    if (filter === 'completed') return todo.completed;
    if (filter === 'active') return !todo.completed;
    return true;
  });
  
  return (
    <ul>
      {filtered.map(todo => (
        <li key={todo.id}>{todo.text}</li>
      ))}
    </ul>
  );
}
```

---

# üîÑ **STATE MANAGEMENT**

---

### **Context API**

| **Definition**  | Built-in React solution for sharing state across component tree.                         |
| --------------- | ---------------------------------------------------------------------------------------- |
| **When to Use** | Theme, auth, language, avoiding prop drilling for non-frequently changing data.         |
| **Remarks**     | All consumers re-render on context change. Split contexts to minimize re-renders.        |

```jsx
import { createContext, useContext, useState } from 'react';

// Create context
const AuthContext = createContext();

// Provider component
function AuthProvider({ children }) {
  const [user, setUser] = useState(null);
  
  const login = async (credentials) => {
    const userData = await loginAPI(credentials);
    setUser(userData);
  };
  
  const logout = () => {
    setUser(null);
  };
  
  const value = {
    user,
    login,
    logout,
    isAuthenticated: !!user
  };
  
  return (
    <AuthContext.Provider value={value}>
      {children}
    </AuthContext.Provider>
  );
}

// Custom hook for consuming context
function useAuth() {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAuth must be used within AuthProvider');
  }
  return context;
}

// Usage in app
function App() {
  return (
    <AuthProvider>
      <Navigation />
      <Dashboard />
    </AuthProvider>
  );
}

function Dashboard() {
  const { user, logout } = useAuth();
  
  return (
    <div>
      <h1>Welcome, {user.name}</h1>
      <button onClick={logout}>Logout</button>
    </div>
  );
}
```

---

### **Redux Integration**

| **Definition**  | External state management library with centralized store.                                |
| --------------- | ---------------------------------------------------------------------------------------- |
| **When to Use** | Complex state, many state transitions, large teams, time-travel debugging.              |
| **Remarks**     | More boilerplate than Context. Use Redux Toolkit for modern Redux. Overkill for small apps.|

```jsx
// store.js - Redux Toolkit
import { configureStore, createSlice } from '@reduxjs/toolkit';

const counterSlice = createSlice({
  name: 'counter',
  initialState: { value: 0 },
  reducers: {
    increment: (state) => {
      state.value += 1;
    },
    decrement: (state) => {
      state.value -= 1;
    },
    incrementByAmount: (state, action) => {
      state.value += action.payload;
    }
  }
});

export const { increment, decrement, incrementByAmount } = counterSlice.actions;

export const store = configureStore({
  reducer: {
    counter: counterSlice.reducer
  }
});

// App.jsx
import { Provider } from 'react-redux';
import { store } from './store';

function App() {
  return (
    <Provider store={store}>
      <Counter />
    </Provider>
  );
}

// Counter.jsx
import { useSelector, useDispatch } from 'react-redux';
import { increment, decrement } from './store';

function Counter() {
  const count = useSelector((state) => state.counter.value);
  const dispatch = useDispatch();
  
  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => dispatch(increment())}>+</button>
      <button onClick={() => dispatch(decrement())}>-</button>
    </div>
  );
}
```

---

### **Zustand**

| **Definition**  | Lightweight state management library with hooks-based API.                               |
| --------------- | ---------------------------------------------------------------------------------------- |
| **When to Use** | Simpler alternative to Redux, medium-sized apps, less boilerplate.                      |
| **Remarks**     | No providers needed. Minimal API. Growing popularity. Great developer experience.        |

```jsx
import create from 'zustand';

// Create store
const useStore = create((set) => ({
  count: 0,
  user: null,
  increment: () => set((state) => ({ count: state.count + 1 })),
  decrement: () => set((state) => ({ count: state.count - 1 })),
  setUser: (user) => set({ user }),
  reset: () => set({ count: 0, user: null })
}));

// Usage in component
function Counter() {
  const count = useStore((state) => state.count);
  const increment = useStore((state) => state.increment);
  
  return (
    <div>
      <p>{count}</p>
      <button onClick={increment}>+</button>
    </div>
  );
}

// Multiple values
function UserProfile() {
  const { user, setUser } = useStore((state) => ({
    user: state.user,
    setUser: state.setUser
  }));
  
  return <div>{user?.name}</div>;
}

// With middleware (persist to localStorage)
import { persist } from 'zustand/middleware';

const usePersistedStore = create(
  persist(
    (set) => ({
      theme: 'light',
      setTheme: (theme) => set({ theme })
    }),
    {
      name: 'app-storage'
    }
  )
);
```

---

### **Jotai**

| **Definition**  | Atomic state management library with bottom-up approach.                                 |
| --------------- | ---------------------------------------------------------------------------------------- |
| **When to Use** | Fine-grained reactivity, derived state, complex dependencies.                            |
| **Remarks**     | Atom-based. Similar to Recoil but simpler. No string keys. TypeScript-friendly.         |

```jsx
import { atom, useAtom } from 'jotai';

// Create atoms
const countAtom = atom(0);
const userAtom = atom({ name: 'Alice', age: 30 });

// Derived atom
const doubleCountAtom = atom((get) => get(countAtom) * 2);

// Write-only atom
const incrementAtom = atom(
  null,
  (get, set) => set(countAtom, get(countAtom) + 1)
);

// Usage
function Counter() {
  const [count, setCount] = useAtom(countAtom);
  const [doubleCount] = useAtom(doubleCountAtom);
  
  return (
    <div>
      <p>Count: {count}</p>
      <p>Double: {doubleCount}</p>
      <button onClick={() => setCount(c => c + 1)}>+</button>
    </div>
  );
}

// Async atom
const userDataAtom = atom(async () => {
  const response = await fetch('/api/user');
  return response.json();
});

function UserProfile() {
  const [userData] = useAtom(userDataAtom);
  
  return <div>{userData.name}</div>;
}
```

---

# üåê **ROUTING (React Router v6)**

---

### **Basic Routing**

| **Definition**  | Client-side routing for single-page applications.                                        |
| --------------- | ---------------------------------------------------------------------------------------- |
| **When to Use** | Multi-page apps, navigation, URL-based rendering.                                        |
| **Remarks**     | Use React Router v6+. Declarative. Supports nested routes, lazy loading.                |

```jsx
import { BrowserRouter, Routes, Route, Link } from 'react-router-dom';

function App() {
  return (
    <BrowserRouter>
      <nav>
        <Link to="/">Home</Link>
        <Link to="/about">About</Link>
        <Link to="/contact">Contact</Link>
      </nav>
      
      <Routes>
        <Route path="/" element={<Home />} />
        <Route path="/about" element={<About />} />
        <Route path="/contact" element={<Contact />} />
        <Route path="*" element={<NotFound />} />
      </Routes>
    </BrowserRouter>
  );
}

// Nested routes
function App() {
  return (
    <Routes>
      <Route path="/" element={<Layout />}>
        <Route index element={<Home />} />
        <Route path="about" element={<About />} />
        <Route path="users" element={<Users />}>
          <Route path=":userId" element={<UserProfile />} />
        </Route>
      </Route>
    </Routes>
  );
}

// Layout with Outlet
import { Outlet } from 'react-router-dom';

function Layout() {
  return (
    <div>
      <Navigation />
      <main>
        <Outlet /> {/* Child routes render here */}
      </main>
      <Footer />
    </div>
  );
}
```

---

### **Navigation Hooks**

| **Definition**  | Programmatic navigation and route information access.                                    |
| --------------- | ---------------------------------------------------------------------------------------- |
| **When to Use** | Form submissions, redirects, accessing URL params/query strings.                        |
| **Remarks**     | Use `useNavigate`, `useParams`, `useLocation`, `useSearchParams`.                       |

```jsx
import {
  useNavigate,
  useParams,
  useLocation,
  useSearchParams
} from 'react-router-dom';

// useNavigate - programmatic navigation
function LoginForm() {
  const navigate = useNavigate();
  
  const handleSubmit = async (credentials) => {
    await login(credentials);
    navigate('/dashboard');
    // navigate(-1); // Go back
    // navigate('/users', { replace: true }); // Replace history
  };
  
  return <form onSubmit={handleSubmit}>...</form>;
}

// useParams - URL parameters
function UserProfile() {
  const { userId } = useParams();
  
  return <div>User ID: {userId}</div>;
}

// Route: <Route path="/users/:userId" element={<UserProfile />} />
// URL: /users/123 ‚Üí userId = "123"

// useLocation - current location object
function Analytics() {
  const location = useLocation();
  
  useEffect(() => {
    trackPageView(location.pathname);
  }, [location]);
  
  return null;
}

// useSearchParams - query strings
function ProductList() {
  const [searchParams, setSearchParams] = useSearchParams();
  
  const category = searchParams.get('category');
  const sort = searchParams.get('sort');
  
  const updateFilters = (newCategory) => {
    setSearchParams({ category: newCategory, sort });
  };
  
  return <div>Category: {category}</div>;
}

// URL: /products?category=electronics&sort=price
```

---

### **Protected Routes**

| **Definition**  | Routes that require authentication or authorization.                                     |
| --------------- | ---------------------------------------------------------------------------------------- |
| **When to Use** | Dashboard, admin pages, user-specific content.                                           |
| **Remarks**     | Common pattern using custom component wrapper and navigation hooks.                      |

```jsx
import { Navigate, Outlet } from 'react-router-dom';

// Protected route wrapper
function ProtectedRoute({ children }) {
  const { user, isLoading } = useAuth();
  
  if (isLoading) {
    return <LoadingSpinner />;
  }
  
  if (!user) {
    return <Navigate to="/login" replace />;
  }
  
  return children ? children : <Outlet />;
}

// Usage
function App() {
  return (
    <Routes>
      <Route path="/login" element={<Login />} />
      
      <Route element={<ProtectedRoute />}>
        <Route path="/dashboard" element={<Dashboard />} />
        <Route path="/profile" element={<Profile />} />
        <Route path="/settings" element={<Settings />} />
      </Route>
    </Routes>
  );
}

// Role-based protection
function AdminRoute({ children }) {
  const { user } = useAuth();
  
  if (!user) {
    return <Navigate to="/login" />;
  }
  
  if (user.role !== 'admin') {
    return <Navigate to="/unauthorized" />;
  }
  
  return children;
}

<Route
  path="/admin"
  element={
    <AdminRoute>
      <AdminPanel />
    </AdminRoute>
  }
/>
```

---

# üì° **DATA FETCHING**

---

### **Fetch API**

| **Definition**  | Native browser API for making HTTP requests.                                             |
| --------------- | ---------------------------------------------------------------------------------------- |
| **When to Use** | Simple GET/POST requests, basic data fetching.                                           |
| **Remarks**     | Promise-based. No automatic retries. Handle errors manually. Use in useEffect.           |

```jsx
function UserList() {
  const [users, setUsers] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  
  useEffect(() => {
    async function fetchUsers() {
      try {
        const response = await fetch('/api/users');
        
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        const data = await response.json();
        setUsers(data);
      } catch (err) {
        setError(err.message);
      } finally {
        setLoading(false);
      }
    }
    
    fetchUsers();
  }, []);
  
  if (loading) return <div>Loading...</div>;
  if (error) return <div>Error: {error}</div>;
  
  return (
    <ul>
      {users.map(user => (
        <li key={user.id}>{user.name}</li>
      ))}
    </ul>
  );
}

// POST request
async function createUser(userData) {
  const response = await fetch('/api/users', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify(userData)
  });
  
  return response.json();
}
```

---

### **React Query / TanStack Query**

| **Definition**  | Powerful data fetching and caching library for React.                                    |
| --------------- | ---------------------------------------------------------------------------------------- |
| **When to Use** | Complex data fetching, caching, background refetching, optimistic updates.              |
| **Remarks**     | Industry standard. Auto caching, retries, refetch on focus. Reduces boilerplate massively.|

```jsx
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';

// Setup QueryClient
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';

const queryClient = new QueryClient();

function App() {
  return (
    <QueryClientProvider client={queryClient}>
      <Users />
    </QueryClientProvider>
  );
}

// useQuery - fetching data
function Users() {
  const { data, isLoading, error, refetch } = useQuery({
    queryKey: ['users'],
    queryFn: async () => {
      const response = await fetch('/api/users');
      return response.json();
    },
    staleTime: 5000, // Consider data fresh for 5s
    cacheTime: 300000, // Keep in cache for 5 minutes
    refetchOnWindowFocus: true
  });
  
  if (isLoading) return <div>Loading...</div>;
  if (error) return <div>Error: {error.message}</div>;
  
  return (
    <div>
      <button onClick={refetch}>Refresh</button>
      {data.map(user => <div key={user.id}>{user.name}</div>)}
    </div>
  );
}

// useMutation - modifying data
function CreateUser() {
  const queryClient = useQueryClient();
  
  const mutation = useMutation({
    mutationFn: (newUser) => {
      return fetch('/api/users', {
        method: 'POST',
        body: JSON.stringify(newUser),
        headers: { 'Content-Type': 'application/json' }
      }).then(res => res.json());
    },
    onSuccess: () => {
      // Invalidate and refetch
      queryClient.invalidateQueries({ queryKey: ['users'] });
    }
  });
  
  const handleSubmit = (userData) => {
    mutation.mutate(userData);
  };
  
  return (
    <div>
      {mutation.isLoading && <p>Creating...</p>}
      {mutation.isError && <p>Error: {mutation.error.message}</p>}
      {mutation.isSuccess && <p>User created!</p>}
      <button onClick={() => handleSubmit({ name: 'Alice' })}>
        Create User
      </button>
    </div>
  );
}

// Dependent queries
function UserPosts({ userId }) {
  const { data: user } = useQuery({
    queryKey: ['user', userId],
    queryFn: () => fetchUser(userId)
  });
  
  const { data: posts } = useQuery({
    queryKey: ['posts', userId],
    queryFn: () => fetchUserPosts(userId),
    enabled: !!user // Only run when user is available
  });
  
  return <div>{/* render posts */}</div>;
}
```

---

### **SWR (Stale-While-Revalidate)**

| **Definition**  | Data fetching library by Vercel with focus on real-time and caching.                     |
| --------------- | ---------------------------------------------------------------------------------------- |
| **When to Use** | Real-time data, simple caching needs, Vercel/Next.js projects.                          |
| **Remarks**     | Lighter than React Query. Great for real-time. Built-in revalidation strategies.        |

```jsx
import useSWR from 'swr';

// Fetcher function
const fetcher = (url) => fetch(url).then(res => res.json());

// Basic usage
function Profile() {
  const { data, error, isLoading } = useSWR('/api/user', fetcher);
  
  if (isLoading) return <div>Loading...</div>;
  if (error) return <div>Failed to load</div>;
  
  return <div>Hello {data.name}!</div>;
}

// With options
function UserList() {
  const { data, error, mutate } = useSWR(
    '/api/users',
    fetcher,
    {
      refreshInterval: 3000, // Refresh every 3s
      revalidateOnFocus: true,
      dedupingInterval: 2000
    }
  );
  
  // Manual revalidation
  const refresh = () => mutate();
  
  return (
    <div>
      <button onClick={refresh}>Refresh</button>
      {data?.map(user => <div key={user.id}>{user.name}</div>)}
    </div>
  );
}

// Conditional fetching
function UserPosts({ userId }) {
  const { data } = useSWR(
    userId ? `/api/users/${userId}/posts` : null,
    fetcher
  );
  
  return <div>{/* render posts */}</div>;
}

// Mutation with optimistic UI
function TodoList() {
  const { data, mutate } = useSWR('/api/todos', fetcher);
  
  const addTodo = async (text) => {
    const newTodo = { id: Date.now(), text, done: false };
    
    // Optimistic update
    mutate([...data, newTodo], false);
    
    // Send to server
    await fetch('/api/todos', {
      method: 'POST',
      body: JSON.stringify(newTodo)
    });
    
    // Revalidate
    mutate();
  };
  
  return <div>{/* render todos */}</div>;
}
```

---

### **Axios**

| **Definition**  | Promise-based HTTP client with more features than Fetch API.                             |
| --------------- | ---------------------------------------------------------------------------------------- |
| **When to Use** | Complex requests, interceptors, automatic JSON transformation, request cancellation.    |
| **Remarks**     | More features than fetch. Auto JSON parsing. Better error handling. Interceptors support.|

```jsx
import axios from 'axios';

// Basic setup with instance
const api = axios.create({
  baseURL: 'https://api.example.com',
  timeout: 5000,
  headers: {
    'Content-Type': 'application/json'
  }
});

// Request interceptor (auth token)
api.interceptors.request.use(
  (config) => {
    const token = localStorage.getItem('token');
    if (token) {
      config.headers.Authorization = `Bearer ${token}`;
    }
    return config;
  },
  (error) => Promise.reject(error)
);

// Response interceptor (error handling)
api.interceptors.response.use(
  (response) => response,
  (error) => {
    if (error.response?.status === 401) {
      // Redirect to login
      window.location.href = '/login';
    }
    return Promise.reject(error);
  }
);

// Usage in component
function UserProfile({ userId }) {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);
  
  useEffect(() => {
    const source = axios.CancelToken.source();
    
    async function fetchUser() {
      try {
        const response = await api.get(`/users/${userId}`, {
          cancelToken: source.token
        });
        setUser(response.data);
      } catch (error) {
        if (!axios.isCancel(error)) {
          console.error('Error:', error.message);
        }
      } finally {
        setLoading(false);
      }
    }
    
    fetchUser();
    
    return () => source.cancel('Component unmounted');
  }, [userId]);
  
  if (loading) return <div>Loading...</div>;
  return <div>{user.name}</div>;
}

// POST request
async function createUser(userData) {
  try {
    const response = await api.post('/users', userData);
    return response.data;
  } catch (error) {
    if (error.response) {
      // Server responded with error
      console.error('Server error:', error.response.data);
    } else if (error.request) {
      // Request made but no response
      console.error('Network error');
    } else {
      console.error('Error:', error.message);
    }
    throw error;
  }
}

// Multiple concurrent requests
async function fetchDashboardData() {
  try {
    const [users, posts, comments] = await Promise.all([
      api.get('/users'),
      api.get('/posts'),
      api.get('/comments')
    ]);
    
    return {
      users: users.data,
      posts: posts.data,
      comments: comments.data
    };
  } catch (error) {
    console.error('Error fetching dashboard data:', error);
  }
}
```

---

# üß™ **TESTING**

---

### **React Testing Library**

| **Definition**  | Testing library focused on testing behavior, not implementation.                         |
| --------------- | ---------------------------------------------------------------------------------------- |
| **When to Use** | Unit and integration tests for React components.                                         |
| **Remarks**     | Best practice for React testing. Tests user interactions. Encourages accessible markup.  |

```jsx
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import '@testing-library/jest-dom';

// Component to test
function Counter() {
  const [count, setCount] = useState(0);
  
  return (
    <div>
      <h1>Count: {count}</h1>
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
}

// Test
describe('Counter', () => {
  test('renders initial count', () => {
    render(<Counter />);
    expect(screen.getByText('Count: 0')).toBeInTheDocument();
  });
  
  test('increments count on button click', () => {
    render(<Counter />);
    const button = screen.getByRole('button', { name: /increment/i });
    
    fireEvent.click(button);
    expect(screen.getByText('Count: 1')).toBeInTheDocument();
    
    fireEvent.click(button);
    expect(screen.getByText('Count: 2')).toBeInTheDocument();
  });
});

// Testing async operations
function UserProfile({ userId }) {
  const [user, setUser] = useState(null);
  
  useEffect(() => {
    fetch(`/api/users/${userId}`)
      .then(res => res.json())
      .then(data => setUser(data));
  }, [userId]);
  
  if (!user) return <div>Loading...</div>;
  return <div>{user.name}</div>;
}

test('loads and displays user', async () => {
  // Mock fetch
  global.fetch = jest.fn(() =>
    Promise.resolve({
      json: () => Promise.resolve({ name: 'Alice' })
    })
  );
  
  render(<UserProfile userId={1} />);
  
  expect(screen.getByText('Loading...')).toBeInTheDocument();
  
  await waitFor(() => {
    expect(screen.getByText('Alice')).toBeInTheDocument();
  });
});

// Testing forms
function LoginForm({ onSubmit }) {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  
  return (
    <form onSubmit={(e) => {
      e.preventDefault();
      onSubmit({ email, password });
    }}>
      <input
        type="email"
        placeholder="Email"
        value={email}
        onChange={(e) => setEmail(e.target.value)}
      />
      <input
        type="password"
        placeholder="Password"
        value={password}
        onChange={(e) => setPassword(e.target.value)}
      />
      <button type="submit">Login</button>
    </form>
  );
}

test('submits form with user input', async () => {
  const handleSubmit = jest.fn();
  render(<LoginForm onSubmit={handleSubmit} />);
  
  const user = userEvent.setup();
  
  await user.type(screen.getByPlaceholderText('Email'), 'test@example.com');
  await user.type(screen.getByPlaceholderText('Password'), 'password123');
  await user.click(screen.getByRole('button', { name: /login/i }));
  
  expect(handleSubmit).toHaveBeenCalledWith({
    email: 'test@example.com',
    password: 'password123'
  });
});
```

---

### **Jest**

| **Definition**  | JavaScript testing framework with assertion library and mocking.                         |
| --------------- | ---------------------------------------------------------------------------------------- |
| **When to Use** | Unit tests, integration tests, snapshot tests.                                           |
| **Remarks**     | Default with Create React App. Fast. Good mocking. Snapshot testing built-in.           |

```jsx
// Basic test
describe('Math operations', () => {
  test('adds 1 + 2 to equal 3', () => {
    expect(1 + 2).toBe(3);
  });
  
  test('object equality', () => {
    const data = { one: 1 };
    data.two = 2;
    expect(data).toEqual({ one: 1, two: 2 });
  });
});

// Mocking functions
test('mock callback', () => {
  const mockFn = jest.fn((x) => x + 1);
  
  mockFn(1);
  mockFn(2);
  
  expect(mockFn).toHaveBeenCalledTimes(2);
  expect(mockFn).toHaveBeenCalledWith(1);
  expect(mockFn).toHaveBeenCalledWith(2);
  expect(mockFn.mock.results[0].value).toBe(2);
});

// Mocking modules
jest.mock('./api', () => ({
  fetchUser: jest.fn()
}));

import { fetchUser } from './api';

test('calls API correctly', async () => {
  fetchUser.mockResolvedValue({ name: 'Alice' });
  
  const user = await fetchUser(1);
  
  expect(fetchUser).toHaveBeenCalledWith(1);
  expect(user.name).toBe('Alice');
});

// Snapshot testing
test('component matches snapshot', () => {
  const { container } = render(<Button>Click me</Button>);
  expect(container).toMatchSnapshot();
});

// Async tests
test('async operation', async () => {
  const data = await fetchData();
  expect(data).toBe('peanut butter');
});

// Setup and teardown
beforeEach(() => {
  // Runs before each test
  setupDatabase();
});

afterEach(() => {
  // Runs after each test
  clearDatabase();
});

beforeAll(() => {
  // Runs once before all tests
});

afterAll(() => {
  // Runs once after all tests
});
```

---

### **Vitest**

| **Definition**  | Modern, fast testing framework similar to Jest but optimized for Vite.                   |
| --------------- | ---------------------------------------------------------------------------------------- |
| **When to Use** | Projects using Vite, faster test execution, ESM support.                                |
| **Remarks**     | Drop-in Jest replacement. Much faster. Better ESM support. Growing adoption.             |

```jsx
import { describe, it, expect, vi } from 'vitest';
import { render, screen } from '@testing-library/react';

// Tests look identical to Jest
describe('Counter', () => {
  it('increments count', () => {
    render(<Counter />);
    const button = screen.getByRole('button');
    button.click();
    expect(screen.getByText(/count: 1/i)).toBeInTheDocument();
  });
});

// Mocking with vi
const mockFn = vi.fn();
mockFn.mockReturnValue(42);

// Module mocking
vi.mock('./api', () => ({
  fetchUser: vi.fn(() => Promise.resolve({ name: 'Alice' }))
}));

// Timer mocking
vi.useFakeTimers();

test('timer test', () => {
  const callback = vi.fn();
  setTimeout(callback, 1000);
  
  vi.advanceTimersByTime(1000);
  
  expect(callback).toHaveBeenCalled();
});

// Spy on functions
const spy = vi.spyOn(console, 'log');
console.log('test');
expect(spy).toHaveBeenCalledWith('test');
```

---

# üîß **TOOLING & ECOSYSTEM**

---

### **Vite**

| **Definition**  | Next-generation frontend build tool with fast dev server and HMR.                        |
| --------------- | ---------------------------------------------------------------------------------------- |
| **When to Use** | New projects, modern builds, fast development experience.                                |
| **Remarks**     | Replaces Create React App. Much faster. Native ESM. Excellent DX. Industry standard now.|

```bash
# Create Vite React project
npm create vite@latest my-app -- --template react
cd my-app
npm install
npm run dev
```

```js
// vite.config.js
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';

export default defineConfig({
  plugins: [react()],
  server: {
    port: 3000,
    open: true
  },
  build: {
    outDir: 'dist',
    sourcemap: true
  },
  resolve: {
    alias: {
      '@': '/src'
    }
  }
});
```

---

### **TypeScript Integration**

| **Definition**  | Superset of JavaScript adding static type checking.                                      |
| --------------- | ---------------------------------------------------------------------------------------- |
| **When to Use** | Large projects, teams, catching bugs early, better IDE support.                         |
| **Remarks**     | Industry standard. Better refactoring. Improved documentation. Slightly more verbose.    |

```tsx
// Component with TypeScript
interface ButtonProps {
  variant?: 'primary' | 'secondary';
  size?: 'small' | 'medium' | 'large';
  disabled?: boolean;
  onClick?: () => void;
  children: React.ReactNode;
}

function Button({
  variant = 'primary',
  size = 'medium',
  disabled = false,
  onClick,
  children
}: ButtonProps) {
  return (
    <button
      className={`btn-${variant} btn-${size}`}
      disabled={disabled}
      onClick={onClick}
    >
      {children}
    </button>
  );
}

// State with types
interface User {
  id: number;
  name: string;
  email: string;
}

function UserProfile() {
  const [user, setUser] = useState<User | null>(null);
  const [loading, setLoading] = useState<boolean>(true);
  
  return <div>{user?.name}</div>;
}

// Custom hook with types
function useFetch<T>(url: string) {
  const [data, setData] = useState<T | null>(null);
  const [error, setError] = useState<Error | null>(null);
  
  useEffect(() => {
    fetch(url)
      .then(res => res.json())
      .then(setData)
      .catch(setError);
  }, [url]);
  
  return { data, error };
}

// Usage
interface Post {
  id: number;
  title: string;
  body: string;
}

function Posts() {
  const { data } = useFetch<Post[]>('/api/posts');
  return <div>{data?.map(post => post.title)}</div>;
}

// Generic component
interface ListProps<T> {
  items: T[];
  renderItem: (item: T) => React.ReactNode;
}

function List<T>({ items, renderItem }: ListProps<T>) {
  return (
    <ul>
      {items.map((item, index) => (
        <li key={index}>{renderItem(item)}</li>
      ))}
    </ul>
  );
}
```

---

### **ESLint**

| **Definition**  | JavaScript linter for code quality and consistency.                                      |
| --------------- | ---------------------------------------------------------------------------------------- |
| **When to Use** | All projects. Enforce code standards, catch errors, maintain consistency.               |
| **Remarks**     | Essential for teams. Many plugins available. Auto-fix many issues.                       |

```js
// .eslintrc.js
module.exports = {
  extends: [
    'eslint:recommended',
    'plugin:react/recommended',
    'plugin:react-hooks/recommended',
    'plugin:@typescript-eslint/recommended'
  ],
  plugins: ['react', 'react-hooks', '@typescript-eslint'],
  rules: {
    'react/react-in-jsx-scope': 'off',
    'react/prop-types': 'off',
    'no-unused-vars': 'warn',
    'react-hooks/rules-of-hooks': 'error',
    'react-hooks/exhaustive-deps': 'warn'
  },
  settings: {
    react: {
      version: 'detect'
    }
  }
};
```

---

### **Prettier**

| **Definition**  | Opinionated code formatter for consistent styling.                                       |
| --------------- | ---------------------------------------------------------------------------------------- |
| **When to Use** | All projects. Removes formatting debates, auto-formats on save.                         |
| **Remarks**     | Works with ESLint. Essential for teams. Saves time. Consistent codebase.                 |

```json
// .prettierrc
{
  "semi": true,
  "trailingComma": "es5",
  "singleQuote": true,
  "printWidth": 80,
  "tabWidth": 2,
  "arrowParens": "always"
}
```

---

# üÜï **REACT 18 FEATURES**

---

### **Automatic Batching**

| **Definition**  | React 18 batches multiple state updates automatically for better performance.            |
| --------------- | ---------------------------------------------------------------------------------------- |
| **When to Use** | Automatic. No changes needed. Works in timeouts, promises, and event handlers.          |
| **Remarks**     | Reduces re-renders. Previously only in React event handlers. Now everywhere.             |

```jsx
// React 17 - 2 renders
function handleClick() {
  setCount(c => c + 1); // Render 1
  setFlag(f => !f);     // Render 2
}

// React 18 - 1 render (batched automatically)
function handleClick() {
  setCount(c => c + 1); // Batched
  setFlag(f => !f);     // Batched
}

// Even in async code (React 18)
async function handleClick() {
  await fetch('/api');
  setCount(c => c + 1); // Batched
  setFlag(f => !f);     // Batched
}

// Opt-out of batching (rare)
import { flushSync } from 'react-dom';

function handleClick() {
  flushSync(() => {
    setCount(c => c + 1); // Renders immediately
  });
  setFlag(f => !f);     // Separate render
}
```

---

### **Concurrent Rendering**

| **Definition**  | React can interrupt rendering to keep UI responsive.                                     |
| --------------- | ---------------------------------------------------------------------------------------- |
| **When to Use** | Enabled automatically with React 18. Use transitions for heavy updates.                 |
| **Remarks**     | Foundation for features like useTransition. Makes apps feel faster. Interruptible.       |

```jsx
// Heavy computation that blocks UI in React 17
function SearchResults({ query }) {
  const results = heavyFilter(items, query); // Blocks UI
  return <div>{results.map(r => <Item key={r.id} />)}</div>;
}

// React 18 - with transitions (non-blocking)
function SearchResults() {
  const [query, setQuery] = useState('');
  const [isPending, startTransition] = useTransition();
  const [results, setResults] = useState([]);
  
  const handleSearch = (value) => {
    setQuery(value); // Urgent
    
    startTransition(() => {
      // This can be interrupted
      setResults(heavyFilter(items, value));
    });
  };
  
  return (
    <div>
      <input value={query} onChange={e => handleSearch(e.target.value)} />
      {isPending && <Spinner />}
      <ResultsList results={results} />
    </div>
  );
}
```

---

### **Suspense for Data Fetching**

| **Definition**  | Declarative way to handle loading states for async components.                           |
| --------------- | ---------------------------------------------------------------------------------------- |
| **When to Use** | With frameworks supporting Suspense (Next.js, Remix) or React Query.                    |
| **Remarks**     | Still experimental for data fetching. Works great with lazy loading. Future of React.    |

```jsx
import { Suspense } from 'react';

// With React.lazy
const LazyComponent = lazy(() => import('./HeavyComponent'));

function App() {
  return (
    <Suspense fallback={<LoadingSpinner />}>
      <LazyComponent />
    </Suspense>
  );
}

// Nested Suspense boundaries
function App() {
  return (
    <Suspense fallback={<PageLoader />}>
      <Header />
      <Suspense fallback={<SidebarLoader />}>
        <Sidebar />
      </Suspense>
      <Suspense fallback={<ContentLoader />}>
        <MainContent />
      </Suspense>
    </Suspense>
  );
}

// With React Query (supports Suspense)
function UserProfile({ userId }) {
  const { data } = useQuery({
    queryKey: ['user', userId],
    queryFn: () => fetchUser(userId),
    suspense: true // Enable Suspense
  });
  
  return <div>{data.name}</div>;
}

function App() {
  return (
    <Suspense fallback={<div>Loading user...</div>}>
      <UserProfile userId={1} />
    </Suspense>
  );
}
```

---

### **Server Components (RSC)**

| **Definition**  | Components that render on the server, reducing client JavaScript bundle.                 |
| --------------- | ---------------------------------------------------------------------------------------- |
| **When to Use** | With Next.js 13+ App Router. For data-heavy components, reducing bundle size.           |
| **Remarks**     | Still evolving. Framework-specific. Can't use hooks/state. Huge performance benefits.    |

```jsx
// app/page.jsx (Server Component - Next.js 13+)
async function Page() {
  // Fetch on server
  const posts = await fetch('https://api.example.com/posts').then(r => r.json());
  
  return (
    <div>
      <h1>Posts</h1>
      {posts.map(post => (
        <article key={post.id}>
          <h2>{post.title}</h2>
          <p>{post.excerpt}</p>
        </article>
      ))}
    </div>
  );
}

// Client Component (for interactivity)
'use client'; // Directive for client component

import { useState } from 'react';

export function Counter() {
  const [count, setCount] = useState(0);
  
  return (
    <button onClick={() => setCount(count + 1)}>
      Count: {count}
    </button>
  );
}

// Mixing Server and Client Components
// ServerComponent.jsx (server)
import { ClientComponent } from './ClientComponent';

async function ServerComponent() {
  const data = await fetchData();
  
  return (
    <div>
      <h1>Server Rendered</h1>
      <ClientComponent data={data} />
    </div>
  );
}
```

---

### **New Root API**

| **Definition**  | New way to render React apps enabling concurrent features.                               |
| --------------- | ---------------------------------------------------------------------------------------- |
| **When to Use** | All new React 18 apps. Required for concurrent features.                                |
| **Remarks**     | Replaces ReactDOM.render. Enables concurrent rendering. One-line change.                 |

```jsx
// React 17 (legacy)
import ReactDOM from 'react-dom';

ReactDOM.render(
  <App />,
  document.getElementById('root')
);

// React 18 (concurrent)
import { createRoot } from 'react-dom/client';

const root = createRoot(document.getElementById('root'));
root.render(<App />);

// With StrictMode
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);

// Unmounting
root.unmount();
```

---

# ‚ö†Ô∏è **COMMON PITFALLS**

---

### **Infinite Loops**

| **Problem**     | useEffect runs infinitely due to missing/wrong dependencies.                             |
| --------------- | ---------------------------------------------------------------------------------------- |
| **Solution**    | Always include all dependencies. Use ESLint exhaustive-deps rule.                        |

```jsx
// BAD - Infinite loop
function Component() {
  const [count, setCount] = useState(0);
  
  useEffect(() => {
    setCount(count + 1); // Creates new render, triggers useEffect again
  }); // Missing dependency array
  
  return <div>{count}</div>;
}

// GOOD
function Component() {
  const [count, setCount] = useState(0);
  
  useEffect(() => {
    setCount(c => c + 1); // Functional update
  }, []); // Runs once
  
  return <div>{count}</div>;
}

// BAD - Object in dependency
function Component({ config }) {
  useEffect(() => {
    fetchData(config);
  }, [config]); // config is new object every render
}

// GOOD - Destructure or useMemo
function Component({ config }) {
  const { apiKey, timeout } = config;
  
  useEffect(() => {
    fetchData({ apiKey, timeout });
  }, [apiKey, timeout]);
}
```

---

### **Stale Closures**

| **Problem**     | Function captures old state values from when it was created.                             |
| --------------- | ---------------------------------------------------------------------------------------- |
| **Solution**    | Use functional updates or include dependencies properly.                                 |

```jsx
// BAD - Stale closure
function Counter() {
  const [count, setCount] = useState(0);
  
  useEffect(() => {
    const timer = setInterval(() => {
      setCount(count + 1); // Always sees initial count (0)
    }, 1000);
    
    return () => clearInterval(timer);
  }, []); // count not in deps
  
  return <div>{count}</div>;
}

// GOOD - Functional update
function Counter() {
  const [count, setCount] = useState(0);
  
  useEffect(() => {
    const timer = setInterval(() => {
      setCount(c => c + 1); // Always gets latest count
    }, 1000);
    
    return () => clearInterval(timer);
  }, []);
  
  return <div>{count}</div>;
}
```

---

### **Direct State Mutation**

| **Problem**     | Mutating state directly doesn't trigger re-renders.                                      |
| --------------- | ---------------------------------------------------------------------------------------- |
| **Solution**    | Always create new objects/arrays when updating state.                                    |

```jsx
// BAD - Direct mutation
function TodoList() {
  const [todos, setTodos] = useState([]);
  
  const addTodo = (text) => {
    todos.push({ id: Date.now(), text }); // Mutates array
    setTodos(todos); // Doesn't trigger re-render
  };
}

// GOOD - Create new array
function TodoList() {
  const [todos, setTodos] = useState([]);
  
  const addTodo = (text) => {
    setTodos([...todos, { id: Date.now(), text }]); // New array
  };
  
  const toggleTodo = (id) => {
    setTodos(todos.map(todo =>
      todo.id === id ? { ...todo, completed: !todo.completed } : todo
    ));
  };
  
  const deleteTodo = (id) => {
    setTodos(todos.filter(todo => todo.id !== id));
  };
}

// BAD - Mutating object
const updateUser = () => {
  user.name = 'Alice'; // Mutates object
  setUser(user); // Doesn't trigger re-render
};

// GOOD - Create new object
const updateUser = () => {
  setUser({ ...user, name: 'Alice' });
};
```

---

### **Missing Keys in Lists**

| **Problem**     | Missing or non-unique keys cause rendering bugs and performance issues.                  |
| --------------- | ---------------------------------------------------------------------------------------- |
| **Solution**    | Always use unique, stable keys. Never use array index for dynamic lists.                 |

```jsx
// BAD - No keys
function List({ items }) {
  return (
    <ul>
      {items.map(item => (
        <li>{item.name}</li> // Warning: missing key
      ))}
    </ul>
  );
}

// BAD - Index as key (for dynamic lists)
function List({ items }) {
  return (
    <ul>
      {items.map((item, index) => (
        <li key={index}>{item.name}</li> // Breaks on reorder/filter
      ))}
    </ul>
  );
}

// GOOD - Unique ID as key
function List({ items }) {
  return (
    <ul>
      {items.map(item => (
        <li key={item.id}>{item.name}</li>
      ))}
    </ul>
  );
}

// GOOD - Composite key when no ID
function List({ items }) {
  return (
    <ul>
      {items.map((item, index) => (
        <li key={`${item.category}-${item.name}-${index}`}>
          {item.name}
        </li>
      ))}
    </ul>
  );
}
```

---

### **Props Drilling**

| **Problem**     | Passing props through many levels of components becomes unwieldy.                        |
| --------------- | ---------------------------------------------------------------------------------------- |
| **Solution**    | Use Context API, state management, or component composition.                             |

```jsx
// BAD - Props drilling
function App() {
  const [user, setUser] = useState(null);
  
  return <Parent user={user} setUser={setUser} />;
}

function Parent({ user, setUser }) {
  return <Child user={user} setUser={setUser} />;
}

function Child({ user, setUser }) {
  return <GrandChild user={user} setUser={setUser} />;
}

function GrandChild({ user, setUser }) {
  return <div>{user.name}</div>;
}

// GOOD - Context API
const UserContext = createContext();

function App() {
  const [user, setUser] = useState(null);
  
  return (
    <UserContext.Provider value={{ user, setUser }}>
      <Parent />
    </UserContext.Provider>
  );
}

function Parent() {
  return <Child />;
}

function Child() {
  return <GrandChild />;
}

function GrandChild() {
  const { user } = useContext(UserContext);
  return <div>{user.name}</div>;
}

// GOOD - Component composition
function App() {
  const [user, setUser] = useState(null);
  
  return (
    <Parent>
      <Child>
        <GrandChild user={user} />
      </Child>
    </Parent>
  );
}
```

---

# üéØ **BEST PRACTICES**

---

### **Component Structure**

| **Best Practice** | Organize components logically with clear responsibilities.                              |
| ----------------- | --------------------------------------------------------------------------------------- |
| **Guidelines**    | One component per file, extract logic to hooks, keep components small and focused.     |

```jsx
// GOOD - Well-structured component
import { useState, useEffect } from 'react';
import { useAuth } from '@/hooks/useAuth';
import { fetchUserData } from '@/api/users';
import { Avatar } from '@/components/Avatar';
import { Button } from '@/components/Button';
import styles from './UserProfile.module.css';

interface UserProfileProps {
  userId: string;
}

export function UserProfile({ userId }: UserProfileProps) {
  // 1. Hooks first
  const { user: currentUser } = useAuth();
  const [userData, setUserData] = useState(null);
  const [loading, setLoading] = useState(true);
  
  // 2. Effects
  useEffect(() => {
    async function loadUser() {
      try {
        const data = await fetchUserData(userId);
        setUserData(data);
      } finally {
        setLoading(false);
      }
    }
    loadUser();
  }, [userId]);
  
  // 3. Event handlers
  const handleFollow = () => {
    // Handle follow logic
  };
  
  // 4. Early returns
  if (loading) return <LoadingSpinner />;
  if (!userData) return <ErrorMessage />;
  
  // 5. Render
  return (
    <div className={styles.profile}>
      <Avatar src={userData.avatar} alt={userData.name} />
      <h1>{userData.name}</h1>
      <p>{userData.bio}</p>
      {currentUser.id !== userId && (
        <Button onClick={handleFollow}>Follow</Button>
      )}
    </div>
  );
}
```

---

### **Naming Conventions**

| **Best Practice** | Use consistent, descriptive naming throughout codebase.                                 |
| ----------------- | --------------------------------------------------------------------------------------- |
| **Guidelines**    | PascalCase for components, camelCase for functions/variables, prefix hooks with "use". |

```jsx
// Components - PascalCase
function UserProfile() {}
function NavigationBar() {}
const ProductCard = () => {};

// Custom hooks - use prefix
function useAuth() {}
function useFetchData() {}
function useLocalStorage() {}

// Event handlers - handle prefix
const handleClick = () => {};
const handleSubmit = (e) => {};
const handleInputChange = (e) => {};

// Boolean variables - is/has/should prefix
const isLoading = false;
const hasError = false;
const shouldRender = true;

// Constants - UPPER_SNAKE_CASE
const API_URL = 'https://api.example.com';
const MAX_RETRY_ATTEMPTS = 3;

// Private/internal - underscore prefix (optional)
const _internalHelper = () => {};
```

---

### **Error Boundaries**

| **Best Practice** | Catch JavaScript errors in component tree and show fallback UI.                         |
| ----------------- | --------------------------------------------------------------------------------------- |
| **Guidelines**    | Wrap components that might error, provide helpful error messages, log errors.          |

```jsx
import { Component } from 'react';

// Error Boundary (must be class component)
class ErrorBoundary extends Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false, error: null };
  }
  
  static getDerivedStateFromError(error) {
    return { hasError: true, error };
  }
  
  componentDidCatch(error, errorInfo) {
    // Log to error reporting service
    console.error('Error caught:', error, errorInfo);
    logErrorToService(error, errorInfo);
  }
  
  render() {
    if (this.state.hasError) {
      return (
        <div className="error-boundary">
          <h1>Something went wrong</h1>
          <p>{this.state.error?.message}</p>
          <button onClick={() => this.setState({ hasError: false })}>
            Try again
          </button>
        </div>
      );
    }
    
    return this.props.children;
  }
}

// Usage
function App() {
  return (
    <ErrorBoundary>
      <Router>
        <Routes>
          <Route path="/" element={<Home />} />
          <Route path="/dashboard" element={
            <ErrorBoundary>
              <Dashboard />
            </ErrorBoundary>
          } />
        </Routes>
      </Router>
    </ErrorBoundary>
  );
}

// Multiple error boundaries
function App() {
  return (
    <ErrorBoundary fallback={<AppErrorFallback />}>
      <Header />
      <ErrorBoundary fallback={<SidebarErrorFallback />}>
        <Sidebar />
      </ErrorBoundary>
      <ErrorBoundary fallback={<ContentErrorFallback />}>
        <MainContent />
      </ErrorBoundary>
    </ErrorBoundary>
  );
}
```

---

### **Folder Structure**

| **Best Practice** | Organize files logically for scalability and maintainability.                           |
| ----------------- | --------------------------------------------------------------------------------------- |
| **Guidelines**    | Group by feature, separate concerns, keep related files together.                      |

```
src/
‚îú‚îÄ‚îÄ components/          # Shared/reusable components
‚îÇ   ‚îú‚îÄ‚îÄ Button/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Button.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Button.module.css
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Button.test.tsx
‚îÇ   ‚îú‚îÄ‚îÄ Card/
‚îÇ   ‚îî‚îÄ‚îÄ Input/
‚îú‚îÄ‚îÄ features/           # Feature-based modules
‚îÇ   ‚îú‚îÄ‚îÄ auth/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ components/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ LoginForm.tsx
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ RegisterForm.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ hooks/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ useAuth.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ api/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ authApi.ts
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ types/
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ auth.types.ts
‚îÇ   ‚îú‚îÄ‚îÄ products/
‚îÇ   ‚îî‚îÄ‚îÄ users/
‚îú‚îÄ‚îÄ hooks/              # Shared custom hooks
‚îÇ   ‚îú‚îÄ‚îÄ useDebounce.ts
‚îÇ   ‚îú‚îÄ‚îÄ useFetch.ts
‚îÇ   ‚îî‚îÄ‚îÄ useLocalStorage.ts
‚îú‚îÄ‚îÄ pages/              # Route components
‚îÇ   ‚îú‚îÄ‚îÄ Home.tsx
‚îÇ   ‚îú‚îÄ‚îÄ Dashboard.tsx
‚îÇ   ‚îî‚îÄ‚îÄ NotFound.tsx
‚îú‚îÄ‚îÄ utils/              # Utility functions
‚îÇ   ‚îú‚îÄ‚îÄ format.ts
‚îÇ   ‚îî‚îÄ‚îÄ validation.ts
‚îú‚îÄ‚îÄ api/                # API client/config
‚îÇ   ‚îú‚îÄ‚îÄ client.ts
‚îÇ   ‚îî‚îÄ‚îÄ endpoints.ts
‚îú‚îÄ‚îÄ types/              # Global TypeScript types
‚îÇ   ‚îî‚îÄ‚îÄ index.ts
‚îú‚îÄ‚îÄ styles/             # Global styles
‚îÇ   ‚îî‚îÄ‚îÄ globals.css
‚îú‚îÄ‚îÄ App.tsx
‚îî‚îÄ‚îÄ main.tsx
```

---

### **Performance Tips**

| **Best Practice** | Write performant React code from the start.                                             |
| ----------------- | --------------------------------------------------------------------------------------- |
| **Guidelines**    | Minimize re-renders, optimize expensive operations, use proper keys.                   |

```jsx
// ‚úì Use React.memo for expensive components
const ExpensiveComponent = memo(({ data }) => {
  return <div>{/* complex render */}</div>;
});

// ‚úì useMemo for expensive calculations
function Component({ items, filter }) {
  const filteredItems = useMemo(() => {
    return items.filter(item => item.category === filter);
  }, [items, filter]);
  
  return <List items={filteredItems} />;
}

// ‚úì useCallback for stable function references
function Parent() {
  const handleClick = useCallback(() => {
    console.log('clicked');
  }, []);
  
  return <MemoizedChild onClick={handleClick} />;
}

// ‚úì Lazy load heavy components
const HeavyChart = lazy(() => import('./HeavyChart'));

function Dashboard() {
  return (
    <Suspense fallback={<Loading />}>
      <HeavyChart />
    </Suspense>
  );
}

// ‚úì Virtualize long lists
import { FixedSizeList } from 'react-window';

function LongList({ items }) {
  return (
    <FixedSizeList
      height={600}
      itemCount={items.length}
      itemSize={50}
    >
      {({ index, style }) => (
        <div style={style}>{items[index].name}</div>
      )}
    </FixedSizeList>
  );
}

// ‚úì Debounce expensive operations
const debouncedSearch = useMemo(
  () => debounce((query) => searchAPI(query), 300),
  []
);

// ‚úó Don't create objects/arrays in render
function Bad() {
  return <Child config={{ key: 'value' }} />; // New object every render
}

// ‚úì Define outside or use useMemo
const config = { key: 'value' };
function Good() {
  return <Child config={config} />;
}
```

---

### **Accessibility**

| **Best Practice** | Make your React apps accessible to everyone.                                            |
| ----------------- | --------------------------------------------------------------------------------------- |
| **Guidelines**    | Use semantic HTML, ARIA attributes, keyboard navigation, alt text.                     |

```jsx
// ‚úì Semantic HTML
function Article() {
  return (
    <article>
      <header>
        <h1>Title</h1>
      </header>
      <main>
        <p>Content</p>
      </main>
      <footer>Author info</footer>
    </article>
  );
}

// ‚úì ARIA labels
function Button() {
  return (
    <button aria-label="Close dialog" onClick={handleClose}>
      <CloseIcon />
    </button>
  );
}

// ‚úì Keyboard navigation
function Menu() {
  return (
    <nav role="navigation">
      <ul>
        <li>
          <a href="/" onKeyDown={handleKeyDown}>
            Home
          </a>
        </li>
      </ul>
    </nav>
  );
}

// ‚úì Form labels
function LoginForm() {
  return (
    <form>
      <label htmlFor="email">Email</label>
      <input
        id="email"
        type="email"
        aria-required="true"
        aria-invalid={hasError}
        aria-describedby="email-error"
      />
      {hasError && (
        <span id="email-error" role="alert">
          Invalid email
        </span>
      )}
    </form>
  );
}

// ‚úì Focus management
function Modal({ isOpen, onClose }) {
  const closeButtonRef = useRef();
  
  useEffect(() => {
    if (isOpen) {
      closeButtonRef.current?.focus();
    }
  }, [isOpen]);
  
  return (
    <div role="dialog" aria-modal="true">
      <button ref={closeButtonRef} onClick={onClose}>
        Close
      </button>
    </div>
  );
}

// ‚úì Alt text for images
<img src={avatar} alt={`${user.name}'s profile picture`} />

// ‚úì Skip to content
function Layout() {
  return (
    <>
      <a href="#main-content" className="skip-link">
        Skip to main content
      </a>
      <nav>...</nav>
      <main id="main-content">...</main>
    </>
  );
}
```

---

# üìö **ADDITIONAL RESOURCES**

---

## **Quick Tips & Best Practices**

**üéØ Always:**
- Use functional components with hooks
- Use TypeScript for type safety
- Implement error boundaries
- Use Context for global state
- Memoize expensive operations
- Write tests for critical features
- Use ESLint and Prettier
- Follow accessibility guidelines
- Keep components small and focused
- Use proper semantic HTML

**‚ö†Ô∏è Avoid:**
- Mutating state directly
- Missing keys in lists
- Props drilling (use Context)
- Index as key for dynamic lists
- Inline object/array definitions in render
- Too many useState calls (use useReducer)
- Premature optimization
- Overly complex components
- Missing error handling
- Ignoring accessibility

**üìñ Understanding Key Concepts:**
- **Virtual DOM & Reconciliation**: How React efficiently updates UI
- **Component Lifecycle**: Mounting, updating, unmounting phases
- **Hooks Rules**: Only at top level, only in React functions
- **Unidirectional Data Flow**: Props down, events up
- **Composition over Inheritance**: Build complex UI from simple components
- **Controlled vs Uncontrolled**: Form handling approaches

**üîß Essential Tools:**
- **React DevTools**: Browser extension for debugging
- **Redux DevTools**: For Redux state debugging
- **React Query DevTools**: Query inspection
- **Vite/Create React App**: Project setup
- **Storybook**: Component development/documentation
- **React Testing Library**: Testing
- **Vercel/Netlify**: Deployment

**üìñ Learning Resources:**
- **Official React Docs**: https://react.dev
- **React TypeScript Cheatsheet**: For TS with React
- **Epic React by Kent C. Dodds**: Comprehensive course
- **React Patterns**: https://reactpatterns.com
- **React Hook Form Docs**: Form handling
- **TanStack Query Docs**: Data fetching

---

## **React Ecosystem Libraries**

**State Management:**
- Redux Toolkit - Complex state
- Zustand - Lightweight state
- Jotai - Atomic state
- Recoil - Meta's state library
- MobX - Observable state

**Routing:**
- React Router - Standard routing
- TanStack Router - Type-safe routing
- Wouter - Minimal router

**Forms:**
- React Hook Form - Performance-focused
- Formik - Full-featured forms
- React Final Form - Subscription-based

**UI Libraries:**
- Material-UI (MUI) - Google's Material Design
- Chakra UI - Accessible component library
- shadcn/ui - Headless components
- Ant Design - Enterprise UI
- Mantine - Modern React components

**Data Fetching:**
- TanStack Query - Powerful data fetching
- SWR - Vercel's solution
- Apollo Client - GraphQL
- RTK Query - Redux data fetching

**Animation:**
- Framer Motion - Production-ready animations
- React Spring - Spring physics animations
- GSAP - Professional animations

**Tables:**
- TanStack Table - Headless table
- React Table - Legacy (now TanStack)
- AG Grid - Enterprise tables

**Drag & Drop:**
- dnd-kit - Modern drag and drop
- react-beautiful-dnd - By Atlassian
- react-dnd - Flexible DnD

---

## **Version History**

**React 18 (March 2022):**
- Concurrent rendering
- Automatic batching
- useTransition, useDeferredValue
- useId hook
- New Suspense features
- Improved hydration

**React 17 (October 2020):**
- No new features
- Gradual upgrades
- Event delegation changes
- New JSX transform

**React 16.8 (February 2019):**
- Hooks introduced
- useState, useEffect, useContext
- Custom hooks
- Rules of Hooks

---

**Pro Tip**: Master the fundamentals (components, props, state, hooks) before diving into advanced patterns. React is simple at its core - most complexity comes from the ecosystem and patterns you choose! üöÄ

**Last Updated**: 2025 - Includes React v18+ features and modern best practices